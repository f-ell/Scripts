#!/usr/bin/perl
use warnings; use strict; $\ = "\n";
# Note: As of 28/09/2022, this script is, mostly, in maintenance mode.

# Features:
# * consider dropping all checks when running with D
# * git-commit -S | git-log --show-signature
# Issue-tracker:
# * git-remote rm doesn't allow '--' syntax % use dynamic opt - but like, why

my $Author    = 'Nico Pareigis';
my ($Program) = $0 =~ m{^.*/(.+)$};
my $Version   = '0.1.7 - maintenance mode';

my sub Err {
  printf STDERR "$Program: %s\n", $_[1];
  exit($_[0]) if $_[0] > 0;
}
my sub SigHandler {
  local $_ = shift;
  Err(  1, 'no help available - '.$_[0])  if /^HelpErr$/;
  Err(  1, 'illegal argument - '.$_[0])   if /^ArgErr$/;
  Err(  2, 'missing branch name.')        if /^BranchErr$/;
  Err(  2, 'missing commit.')             if /^CommErr$/;
  Err(  2, 'nothing to debug.')           if /^DebugErr$/;
  Err(  2, 'missing filename.')           if /^FileErr$/;
  Err(  2, 'missing destination.')        if /^MvDErr$/;
  Err(  2, 'missing name.')               if /^NameErr$/;
  Err(  2, 'missing tagname.')            if /^TagErr$/;
  Err(  2, 'missing URL.')                if /^URLErr$/;
  Err(  3, 'not in a git repository.')    if /^RepoErr$/;
  Err(  4, 'dependency not met - '.$_[0]) if /^DepErr$/;
  Err(130, 'caught interrupt.')           if /^INT|TERM$/;
}
my sub TargetErrHandler($$) {
  local $_  = shift;
  my $O     = shift;
  my $Err   = 'File';
  if ((/^switch$/ and $O =~ /\Wd\W/) or /^revert$/) {
    $Err = 'Comm';
  }
  elsif (/^branch|merge|switch$/) {
    $Err = 'Branch';
  }
  elsif (/^clone$/)   { $Err = 'URL'; }
  elsif (/^remote$/)  { $Err = 'Name'; }
  elsif (/^tag$/)     { $Err = 'Tag'; }
  SigHandler($Err.'Err');
}
@SIG{'INT','TERM'} = (\&SigHandler) x 2;

my sub D {
  return "    D
      Run $Program in debug mode. Print relevant information to STDOUT, but
      don't run the actual git command.";
}
my sub h {
  return "    [-]h [OPT]
      Print help information and exit.
      When passed a valid option name as the first parameter, only print infor-
      mation concerning that option. Subsequent parameters are discarded.";
}
my sub a {
  return "    a [p] -- FILE...
      Run 'git add' on FILE... .
        'p' => --patch";
}
my sub b {
  return "    b [cdlm] [-- BRANCH...]
      Run 'git branch' on BRANCH.
        'c' => -c
        'd' => -d
        'l' => --list, default
        'm' => -m";
}
my sub c {
  return "    c [a] ['commit msg' [%% 'secondary commit msg']] -- FILE...
      Run 'git commit' on FILE... .
        'a' => --amend

      Optionally takes one or two commit messages, where '%%' acts as a sepa-
      rator between the two. The second commit message is passed as a submes-
      sage to git.
      NOTE: Unquoted double dashes in commit mesages will break parsing!";
}
my sub d {
  return "    d [c] [COMMIT...] [-- FILE...]
      Run 'git diff' on the repository, COMMIT... and/or FILE... .
        'c' => --cached";
}
my sub f {
  return "    f
      Run 'git fetch' on the current repository.";
}
my sub i {
  return "    i [b] [BRANCH] [-- DIR]
      Run 'git init' on the current directory or DIR.
        'b'      => --bare
        'BRANCH' => -b BRANCH (default is '-b master')";
}
my sub l {
  return "    l [ls] [n] [INT|a] [-- FILE...]
      Run 'git log --abbrev-commit' on the current repository, or on FILE... .
        'l'   => --pretty=medium
        's'   => --pretty=oneline, default
        'n'   => --name-only
        'INT' => -INT (default is '-4', 'a' unsets this)";
}
my sub _m {
  return "    m [acq] [-- BRANCH]
      Run 'git merge' on BRANCH.
        'a' => --abort
        'c' => --continue
        'q' => --quit";
}
my sub _s {
  return "    s [ls] [a] [-- FILE...]
      Run 'git status' on the current repository, or on FILE... .
        'l' => --long
        's' => -s, default
        'a' => --ahead-behind";
}
my sub t {
  return "    t [adlns] [tag msg] -- TAG [OBJECT...]
      Run 'git tag' with TAG as the tag's name on OBJECT.
        'a' => -a
        'd' => -d
        'l' => -l, default
        'n' => -n
        's' => -s

      Optionally takes tag messages. The format is the same as for 'c'.";
}
my sub cl {
  return "    cl [INT] -- URL [DIR]
      Clone the repository located at URL to DIR.
        'INT' => --depth INT

      Omitting the URL schema assumes https. A URL starting with a percent sign
      (%) is assumed to refer to a github repository. Local repositories may be
      cloned with both relative and absolute URLs.

      '$Program cl -- [https://]github.com/user/repo | %user/repo'
      will try to clone a repository at 'https://github.com/user/repo'";
}
my sub mv {
  return "    mv -- SOURCE... DEST
      Run 'git mv' on SOURCE... DEST.";
}
my sub pl {
  return "    pl [nr]
      Run 'git pull' on the current repository.
        'n' => --no-rebase, default
        'r' => --rebase";
}
my sub ps {
  return "    ps
      Run 'git push' on the current repository.";
}
my sub rm {
  return "    rm [cn] [r] -- FILE...
      Run 'git rm' on FILE... .
        'c' => --cached, default
        'n' => \"not --cached\"
        'r' => -r";
}
my sub sh {
  return "    sh [ls] [-- OBJECT...]
      Run 'git show --abbrev-commit' on OBJECT... .
        'l' => --pretty=medium
        's' => --pretty=oneline, default";
}
my sub st {
  return "    st [clous] [-- FILE...]
      Run 'git stash' on FILE... .
        'c' => clear
        'l' => list
        'o' => pop
        'u' => push
        's' => show";
}
my sub sw {
  return "    sw [d] -- BRANCH|COMMIT
      Run 'git switch' on BRANCH or COMMIT.
        'd' => -d";
}
my sub rem {
  return "    rem [arRsuv] [-- NAME]
      Run 'git remote' on NAME.
        'a' => add
        'r' => rename
        'R' => rm
        's' => show
        'u' => set-url
        'v' => -v, default";
}
my sub res {
  return "    res [ns] -- FILE...
      Run 'git restore' on FILE... .
        'n' => \"not --staged\"
        's' => --staged, default";
}
my sub rev {
  return "    rev [en] -- COMMIT...
      Run 'git revert' on COMMIT... .
        'e' => -e, default
        'n' => --no-edit";
}

my @Help = (
  D, h, a, b, c, d, f, i, l, _m, _s, t,
  cl, mv, pl, ps, rm, sh, st, sw,
  rem, res, rev
);
my sub Help {
print "NAME
    $Program - shorthands for git commands

SYNOPSIS
    $Program [D] [OPT [SUBOPTS]] [-- BRANCH|COMMIT|NAME|FILE|OBJECT|TAG|URL]

DESCRIPTION
    $Program aims to provide some useful shorthands for basic git operations. It
    doesn't try to support all of git's features or functionality.
    Running $Program without any options runs 'git status -s' on the repository.

    $Program currently provides shorthands for the following commands:
    add, branch, clone, commit, diff, fetch, init, log, merge, mv, pull, push,
    remote, restore, revert, rm, show, stash, status, switch, tag

    $Program supports 'verbatim' strings - they are passed verbatim to Git and
    can be used to access options that are not natively supported. They are use-
    able in conjunction with $Program\'s builtin options.
    A verbatim string is embedded by enclosing it in percent signs (%).
    Omitting the second percent sign matches against '--' / EOL.

    NOTE: Verbatim strings are not validated any further; they may clash with
    $Program\'s default options. When used alongside a commit message, try to
    embed the string before, or after the message(s). Be wary when using a '%'
    inside of a commit message, ideally embed the message itself as a verbatim
    string.

OPTIONS";
print foreach @Help;
print "EXIT STATUS
    0, on success
    1, on argument error
    2, when missing filename or similar
    3, when trying to run outside of a git repository
    4, on dependency error
  130, on keyboard interrupt

DEPENDENCIES
    git

VERSION
    $Version

AUTHOR(S)
    $Author";
}


my $Debug     = ''; my $TargetOpt = ''; my $TargetReq = '';
my @Optional  = ('d', 'i', 'l', 's', 'sh', 'st');
my @Requires  = (
  'a', 'b', 'c', 'm', 't', 'cl', 'mv', 'rm', 'sw', 'rem', 'res', 'rev'
);


# Preliminary checks
# ------------------
# Dependencies:
`git -v 2>/dev/null` or SigHandler('DepErr', 'git');

# Help, Debug, Requires / Optional:
if (local $_ = $ARGV[0]) {
  if (/^(?:-)?h|--help|-\?$/) {
    do { Help();    exit(0); }  if not $ARGV[1];
    do { print $_;  exit(0); }  if local ($_) = grep(/^\s*$ARGV[1]\W/, @Help);
    SigHandler('HelpErr', $ARGV[1]);
  }

  do { $Debug = 'True'; shift; }  if /^D$/;
  SigHandler('DebugErr')          if $Debug and not $ARGV[0];

  foreach (@Requires) { do { $TargetReq = 'True'; last } if /^$ARGV[0]$/ };
  foreach (@Optional) { do { $TargetOpt = 'True'; last } if /^$ARGV[0]$/ };
}


# -----------------
# Option processing
# -----------------
my $Action  = ''; my $Opts = ''; my @Targets  = ();
my %Disp    = (); my %Prio = (); my %Rstr     = (); my @Args;

my sub Default() {
  $Action = 'status';
  $Opts   = '-s';
}

my sub OptProc($\%\%\%\@) {
  my $Action  = shift;  # action
  my $Opts    = '';     # internal optstring
  my $Verb    = '';     # verbatim optstring
  my $rDisp   = shift;  # dispatch table
  my $rPrio   = shift;  # priority hash
  my $rRstr   = shift;  # restrict hash
  my $rArgs   = shift;  # arguments
  my %Disp = %$rDisp; my %Prio = %$rPrio;
  my %Rstr = %$rRstr; my @Args = @$rArgs;
  undef $rDisp; undef $rPrio; undef $rRstr; undef $rArgs;

  # Helper subroutines
  my sub DynProc($) {
    local $_ = shift;
    if ($Action eq 'clone' and $Disp{_1} eq '' and /^\d+$/) {
      return (1, '--depth '.$_) 
    }
    if ($Action =~ /^commit|tag$/ and $Disp{_1} eq '') {
      my ($M1, $M2);
      unshift(@Args, $_); s/"/\\"/g foreach @Args;
      join(' ', @Args) =~ /^(.*?)(?:\s+%%\s+(.*?))?$/;
        $1 and $M1 = "-m \"$1\"" or $M1 = '';
        $2 and $M2 = "-m \"$2\"" or $M2 = '';
      undef @Args;
      return (1, $M1.' '.$M2);
    }
    if ($Action =~ /^diff|show$/ and $Disp{_1} eq '') {
      unshift(@Args, $_); my $Commits = join(' ', @Args); undef @Args;
      return(1, $Commits);
    }
    if ($Action eq 'init' and $Disp{_1} eq '-b master') {
      return (1, '-b '.$_);
    }
    if ($Action eq 'log' and $Disp{_1} eq '-4') {
      return (1, ' ')     if /^a$/;
      return (1, '-'.$_)  if /^\d+$/;
    }

    return undef;
  }

  my sub PrioSort(\%) {
    my $Hash = shift;
    foreach (keys %$Hash) {
      if (not $Prio{$_}) {
        do {  $Prio{$_} = 9; next; } if /^D$/;
              $Prio{$_} = 0;
      }
    }
    sort { return -1 * ($Prio{$a} <=> $Prio{$b}); } keys %$Hash;
  }

  my sub RstrRemove($) {
    my $K = shift;
    if (local $_ = $Rstr{$K}) {
      my @Rstr = split(':');
      delete $Disp{$_} foreach @Rstr;
    }
  }

  # Actual processing
  my $S = join(' ', @Args); $S =~ /((?<!%)%(?!%)(.+?)(?(?=(?<!%)%(?!%))%|$))/;
  if ($2) {
    $Verb = $2;
    $S =~ s/$1//;
    @Args = split(' ', $S);
  }

  while (local $_ = shift @Args) {
    if ($Disp{$_}) { # Processes static options
      $Opts .= $Disp{$_}.' ';
      delete $Disp{$_};
      delete $Prio{$_} if $Prio{$_};
      RstrRemove($_);
    }
    else { # Processes dynamic option
      my ($K, $V) = DynProc($_);
      $K and $Disp{'_'.$K} = $V or SigHandler('ArgErr', $_);
    }
  }

  foreach (PrioSort %Disp) {
    next if $Prio{$_} < 0 or not $Disp{$_};
    RstrRemove($_);
    $Opts .= $Disp{$_}.' ';
  }
  return $Opts.' '.$Verb;
}

my sub TargetProc($$$) {
  my $Action    = shift;
  my $Opts      = shift;
  my $TargetReq = shift;
  my @Targets   = @ARGV; shift @Targets if @Targets and $Targets[0] eq '--';

  local $_ = $Action;
  # Verify sufficient number of targets present:
  undef $TargetReq if /^branch$/ and $Opts =~ /--list/;
  undef $TargetReq if /^commit$/ and $Opts =~ /--amend/;
  undef $TargetReq if /^merge$/  and $Opts =~ /--(abort|continue|quit)/;
  undef $TargetReq if /^remote$/ and $Opts =~ /-v/;
  undef $TargetReq if /^tag$/    and $Opts =~ /-l|-n/;
  if ($TargetReq) {
    if (scalar @Targets == 1) {
      SigHandler('MvDErr')  if /^mv$/;
      SigHandler('URLErr')  if /^remote$/ and $Opts =~ /add/;
      SigHandler('NameErr') if /^remote$/ and $Opts =~ /rename/;
    }
    elsif (not @Targets) { TargetErrHandler($_, $Opts); }
  }

  # Edge-case handling:
  if (/^clone$/ and local $_ = $Targets[0]) {
    unless (m{^(?:\.)?/}) {
      my $Schema = ''; my $Host = '';
      $Schema = 'https://'    if m{^(?!http(?:s)?://)};
      $Host   = 'github.com'  if m{^%.*$};
      s/%/\//; $Targets[0] = $Schema.$Host.$_;
    }
  }
  elsif (/^rm$/ and $Opts =~ /(?<!--cached)-r(?!--cached)/ and not $Debug) {
    print STDERR "+---------+\n| WARNING |\n+---------+";
    my $Confirm = '';
    until ($Confirm =~ /^(?:y|n|\n)$/i) {
      printf 'Confirm non-cached, recursive removal (y/N): ';
      $Confirm = <STDIN>;
    }
    SigHandler('INT') if $Confirm =~ /^(?:n)?\n$/i;
  }
  elsif (/^switch$/ and not $Opts and not @Targets) {
    @Targets = 'master';
  }

  # Escape spaces:
  s/ /\\ /g foreach @Targets;
  return @Targets;
}


if (local $_ = shift) {
  if (/^a$/) {
    $Action = 'add';
    %Disp = (p => '--patch');
    %Prio = (p => -1);
  }
  elsif (/^b$/) {
    $Action = 'branch';
    %Disp = (c => '-c',     d => '-d',    l => '--list',  m => '-m');
    %Prio = (c => 1,        d => 1,       l => 2,         m => 1);
    %Rstr = (c => 'd:l:m',  d => 'c:l:m', l => 'c:d:m',   m => 'c:d:l');
  }
  elsif (/^c$/) {
    $Action = 'commit';
    %Disp = (a => '--amend', _1 => '');
    %Prio = (a => -1);
  }
  elsif (/^d$/) {
    $Action = 'diff';
    %Disp = (c => '--cached', _1 => '');
    %Prio = (c => -1);
  }
  elsif (/^f$/) { $Action = 'fetch'; }
  elsif (/^l$/) {
    $Action = 'log';
    %Disp = (
      D => '--abbrev-commit',  s => '--pretty=oneline', l => '--pretty=medium',
      n => '--name-only',     _1 => '-4'
    );
    %Prio = (s => 2,    l => 1,   n => -1);
    %Rstr = (s => 'l',  l => 's');
  }
  elsif (/^i$/) {
    $Action = 'init';
    %Disp = (b => '--bare', _1 => '-b master');
    %Prio = (b => -1);
  }
  elsif (/^m$/) {
    $Action = 'merge';
    %Disp = (a => '--abort',  c => '--continue',  q => '--quit');
    %Prio = (a => -1,         c => -2,            q => -2);
    %Rstr = (a => 'c:q',      c => 'a:q',         q => 'a:c');
  }
  elsif (/^s$/) {
    $Action = 'status';
    %Disp = (s => '-s', l => '--long',  a => '--ahead-behind');
    %Prio = (s => 2,    l => 1,         a => -1);
    %Rstr = (s => 'l',  l => 's');
  }
  elsif (/^t$/) {
    $Action = 'tag';
    %Disp = (
      a => '-a', d => '-d', l => '-l', n => '-n', s => '-s', _1 => ''
    );
    %Prio = (a => 1, d => 1, l => 2, n => 1, s => 1);
    %Rstr = (
      a => 'd:l:n:s', d => 'a:l:n:s', l => 'a:d:n:s', n => 'a:d:l:s',
      s => 'a:d:l:n'
    );
  }
  elsif (/^cl$/) {
    $Action = 'clone';
    %Disp = (_1 => '');
  }
  elsif (/^mv$/) { $Action = 'mv'; }
  elsif (/^pl$/) {
    $Action = 'pull';
    %Disp = (n => '--no-rebase',  r => '--rebase');
    %Prio = (n => 2,              r => 1);
    %Rstr = (n => 'r',            r => 'n');
  }
  elsif (/^ps$/) { $Action = 'push'; }
  elsif (/^rm$/) {
    $Action = 'rm';
    %Disp = (c => '--cached', n => ' ', r => '-r');
    %Prio = (c => 2,          n => 1,   r => -1);
    %Rstr = (c => 'n',        n => 'c');
  }
  elsif (/^sh$/) {
    $Action = 'show';
    %Disp = (
      D => '--abbrev-commit', l => '--pretty=medium',  s => '--pretty=oneline',
      _1 => ''
    );
    %Prio = (l => 1,    s => 2);
    %Rstr = (l => 's',  s => 'l');
  }
  elsif (/^st$/) {
    $Action = 'stash';
    %Disp = (
      c => 'clear', l => 'list', o => 'pop', u => 'push', s => 'show'
    );
    %Prio = (c => 1, l => 2, o => 1, u => 1, s => 1);
    %Rstr = (
      c => 'l:o:u:s',  l => 'c:u:o:s', o => 'c:l:u:s', u => 'c:l:o:s',
      s => 'c:l:o:u'
    );
  }
  elsif (/^sw$/) {
    $Action = 'switch';
    %Disp = (d => '-d');
    %Prio = (d => -1);
  }
  elsif (/^rem$/) {
    $Action = 'remote';
    %Disp = (
      a => 'add', r => 'rename', R => 'rm', s => 'show', u => 'set-url',
      v => '-v'
    );
    %Prio = (a => 1, r => 1, R => 1, s => 1, u => 1, v => 2);
    %Rstr = (
      a => 'r:R:s:u:v', r => 'a:R:s:u:v', R => 'a:r:s:u:v', s => 'a:r:R:u:v',
      u => 'a:r:R:s:v', v => 'a:r:R:s:u'
    );
  }
  elsif (/^res$/) {
    $Action = 'restore';
    %Disp = (s => '--staged', n => ' ');
    %Prio = (s => 2,          n => 1);
    %Rstr = (s => 'n',        n => 's');
  }
  elsif (/^rev$/) {
    $Action = 'revert';
    %Disp = (e => '-e', n => '--no-edit');
    %Prio = (e => 2,    n =>  1);
    %Rstr = (e => 'n',  n => 'e');
  }
  elsif (/^--$/) {
    Default();
  } else { SigHandler('ArgErr', $_); }

  if (not /^--$/) { # Generate @Args
    push(@Args, shift) until not @ARGV or $ARGV[0] eq '--';
  }

  $Opts     = OptProc($Action, %Disp, %Prio, %Rstr, @Args) if not $Opts;
  @Targets  = TargetProc($Action, $Opts, $TargetReq);
} else { Default(); } # Got no arguments


# Exception handling
# ------------------
unless ($Debug) {
  if ($Action eq 'status' and $Opts =~ /--ahead-behind/) {
    `git status --ahead-behind` =~ /(Your branch is .*\.)/;
    print $1 if $1; exit(0);
  }
}

# Build command string
# --------------------
my $Command = "git $Action $Opts -- @Targets"; $Command =~ s/\s+/ /g;

# Repository check
# ----------------
unless ($Debug or $Action =~ /^clone|init$/) {
  `git rev-parse --is-inside-git-dir 2>/dev/null` or SigHandler('RepoErr');
}

# Debugging information / Git command execution
# ---------------------------------------------
if ($Debug) {
  $TargetReq or $TargetReq = 'False';
  $TargetOpt or $TargetOpt = 'False';
  print "- DEBUG MODE -\nAction: $Action\nOpts:   $Opts\n";
  print "TargetReq: $TargetReq\nTargetOpt: $TargetOpt\nTarget(s):";
  print "    $_" foreach @Targets;
  print "\nGit command to be run:\n    $Command";
} else { system("$Command"); }
