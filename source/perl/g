#!/usr/bin/perl
use warnings;
use strict;
$\ = "\n";

# potential issues preceeded by 'TODO' comments
# Issue:
#   * triple-exclusives don't work with optproc implementation
#     * process $Rstr{$_} on a per-character basis and
#     delete $Rstr{$_} foreach character
#
# Feature:
#   * git-clone --bare, --shallow, n name
#
#   * git-branch ('b')    -- list, create, delete
#   * git-checkout ('ch') -- switch commit
#   * git-init ('i(n)') (option for branch, bare, directory ($TargetOpt))
#     * needs exception to be run outside repo (see git-clone)
#   * git-merge ('m')     -- --abort, --continue
#   * git-switch ('sw')   -- switch branch
#   * git-stash ('st')

my $Author    = 'Nico Pareigis';
my ($Program) = $0 =~ m{^.*/(.+)$};
my $Version   = '0.1.4';

my sub Err {
  printf STDERR "Error: %s\n", $_[1];
  exit($_[0]) if $_[0] > 0;
}
my sub SigHandler {
  local $_ = shift;
  Err(1, 'No help available - '.$_[0])        if /HelpErr/;
  Err(1, 'Illegal argument - '.$_[0])         if /ArgErr/;
  Err(2, 'No commit specified!')              if /CommErr/;
  Err(2, 'Nothing to debug!')                 if /DebugErr/;
  Err(2, 'No filename specified!')            if /FileErr/;
  Err(2, 'Missing destination!')              if /MvDErr/;
  Err(2, 'No URL specified!')                 if /URLErr/;
  Err(3, 'Not running in a git repository!')  if /RepoErr/;
  Err(4, 'Dependency not met - '.$_[0])       if /DepErr/;
  Err(130, 'Execution interrupted by user action.') if /SigInt/;
}
$SIG{INT}   = sub { SigHandler('SigInt'); };
$SIG{TERM}  = sub { SigHandler('SigInt'); };

my sub D {
  return "    D
      Run $Program in debug mode. Print relevant information to STDOUT, but
      don't run the actual git command.\n";
}
my sub h {
  return "    [-]h [OPT]
      Print help information and exit.
      When passed a valid option name as the first parameter, only print infor-
      mation concerning that option. Subsequent parameters are discarded.\n";
}
my sub a {
  return "    a [p] -- FILE...
      Run 'git add' on FILE... .
        'p' => --patch\n";
}
my sub c {
  return "    c [a] ['commit msg' [%% 'secondary commit msg']] -- FILE...
      Run 'git commit' on FILE... .
        'a' => --amend

      Optionally takes one or two commit messages, where '%%' acts as a sepa-
      rator between the two. The second commit message is passed as a submes-
      sage to git.
      NOTE: double dashes in commit mesages will break parsing!\n";
}
my sub d {
  return "    d [c] [COMMIT...] [-- FILE...]
      Run 'git diff' on the repository, COMMIT... and/or FILE... .
        'c' => --cached\n";
}
my sub f {
  return "    f
      Run 'git fetch' on the current repository.\n";
}
my sub l {
  return "    l [sl] [n] [INT] [-- FILE...]
      Run 'git log --abbrev-commit' on the current repository, or on FILE... .
        's' => --pretty=oneline, default
        'l' => --pretty=medium
        'n' => --name-only

      Optionally takes an integer to specify the number of commits to show (de-
      fault is 4).\n";
}
my sub _s {
  return "    s [sl] [c] [-- FILE...]
      Run 'git status' on the current repository, or on FILE... .
        's' => -s, default
        'l' => --long
        'c' => --ahead-behind\n";
}
my sub cl {
  return "    cl -- URL
      Clone the repository located at URL.
      Omitting the URL schema assumes https. A URL starting with a percent sign
      (%) is assumed to refer to a github repository. Local repositories may be
      cloned with both relative and absolute URLs.

      '$Program cl -- [https://]github.com/user/repo | %user/repo'
      will try to clone a repository at 'https://github.com/user/repo'\n";
}
my sub mv {
  return "    mv -- SOURCE... DEST
      Run 'git mv' on SOURCE... DEST.\n";
}
my sub pl {
  return "    pl [nr]
      Run 'git pull' on the current repository.
        'n' => --no-rebase, default
        'r' => --rebase\n";
}
my sub ps {
  return "    ps
      Run 'git push' on the current repository.\n";
}
my sub rm {
  return "    rm [cn] [r] -- FILE...
      Run 'git rm' on FILE... .
        'c' => --cached, default
        'n' => not --cached
        'r' => -r\n";
}
my sub res {
  return "    res [sn] -- FILE...
      Run 'git restore' on FILE... .
        's' => --staged, default
        'n' => not --staged\n";
}
my sub rev {
  return "    rev [en] -- COMMIT...
      Run 'git revert' on COMMIT... .
        'e' => -e, default
        'n' => --no-edit\n";
}

my %Help = (
  D => D(), h => h(), a => a(), c => c(),
  d => d(), f => f(), l => l(), s => _s(),
  cl => cl(), mv => mv(), pl => pl(), ps => ps(),
  rm  => rm(),
  res => res(), rev => rev()
);
sub Help {
print <<EOF
NAME
    $Program - shorthands for git commands

SYNOPSIS
    $Program [D] [OPTS [SUBOPTS]] [-- FILE...|COMMIT...|URL]

DESCRIPTION
    $Program aims to provide some useful shorthands for basic git operations. It
    doesn't try to support all of git's features or functionality.
    Running $Program without any options runs 'git status -s' on the repository.

    $Program currently provides shorthands for the following commands:
    add, clone, commit, diff, fetch, log, mv, pull, push, rm, restore, revert,
    status

OPTIONS
$Help{D}\n$Help{h}\n$Help{a}\n$Help{c}
$Help{d}\n$Help{f}\n$Help{l}\n$Help{s}
$Help{cl}\n$Help{mv}\n$Help{pl}\n$Help{ps}
$Help{rm}
$Help{res}\n$Help{rev}
EXIT STATUS
    0, on success
    1, on argument error
    2, when missing filename or similar
    3, when trying to run outside of a git repository
    4, on dependency error
  130, on user action

DEPENDENCIES
    git

VERSION
    $Version

AUTHOR(S)
    $Author
EOF
; exit(0);
}


my $Debug     = '';
my @Optional  = ('d', 'l', 's');
my @Requires  = ('a', 'c', 'cl', 'mv', 'rm', 'res', 'rev');
my $TargetOpt = ''; my $TargetReq = '';


# Preliminary checks
# ------------------
# Dependencies:
`git -v 2>/dev/null` or SigHandler('DepErr', 'git');

# Help, Debug, Requires / Optional:
if (local $_ = $ARGV[0]) {
  if (/^(?:(-)?h|--help|-\?)$/) {
    do { Help(); exit(0) }          if not $ARGV[1];
    SigHandler('HelpErr', $ARGV[1]) if not $Help{$ARGV[1]};
    print "$Help{$ARGV[1]}"; exit(0);
  }

  do { $Debug = 'True'; shift; }  if /^D$/;
  SigHandler('DebugErr')          if $Debug and not $ARGV[0];

  foreach (@Requires) { do { $TargetReq = 'True'; last } if /^$ARGV[0]$/ };
  foreach (@Optional) { do { $TargetOpt = 'True'; last } if /^$ARGV[0]$/ };
}


# -----------------
# Option processing
# -----------------
my $Action; my $Opts; my @Targets; my $NoProc;
my %Disp = (); my %Prio = (); my %Rstr = (); my @Args;

my sub Default() {
  $Action = 'status';
  $Opts   = '-s';
}

my sub OptProc($\%\%\%\@) {
  my $Action  = shift; # action
  my $Opts    = '';    # internal Optstring
  my $rDisp   = shift; # dispatch table
  my $rPrio   = shift; # priority hash
  my $rRstr   = shift; # restrict hash
  my $rArgs   = shift; # arguments
  my %Disp = %$rDisp; my %Prio = %$rPrio;
  my %Rstr = %$rRstr; my @Args = @$rArgs;
  undef $rDisp; undef $rPrio; undef $rRstr; undef $rArgs;

  my sub DynProc($) {
    local $_ = shift;
    return (1, '-'.$_) if $Action eq 'log' and $Disp{_1} eq '-4' and /^\d+$/;

    if ($Action eq 'diff' and $Disp{_1} eq '') {
      unshift(@Args, $_); my $Commits = join(' ', @Args); undef @Args;
      return(1, $Commits);
    }

    if ($Action eq 'commit' and $Disp{_1} eq '') {
      my $Msg1; my $Msg2;
      unshift(@Args, $_); s/"/\\"/g foreach @Args;
      join(' ', @Args) =~ /^(.*?)(?:\s+%%\s+(.*?))?$/;
      $1 and $Msg1 = "-m \"$1\"" or $Msg1 = '';
      $2 and $Msg2 = "-m \"$2\"" or $Msg2 = '';
      undef @Args;
      return (1, $Msg1.' '.$Msg2);
    }

    return undef;
  }

  my sub PrioSort(\%) {
    my $Hash = shift; $Prio{(%$Hash)[0]} = 0 if scalar %$Hash == 1;
    sort
    { $Prio{$a} = 9 if $a eq 'D';     $Prio{$b} = 9 if $b eq 'D';
      $Prio{$a} = 0 if not $Prio{$a}; $Prio{$b} = 0 if not $Prio{$b};
      return -1 * ($Prio{$a} <=> $Prio{$b});
    } keys %$Hash;
  }

  while (local $_ = shift @Args) {
    if ($Disp{$_}) { # Processes static options
      $Opts .= $Disp{$_}.' ';
      delete $Disp{$_};
      delete $Disp{$Rstr{$_}} if $Rstr{$_};
    }
    else { # Processes dynamic option
      my ($K, $V) = DynProc($_);
      $K and $Disp{'_'.$K} = $V or SigHandler('ArgErr', $_);
    }
  }

  foreach (PrioSort %Disp) {
    next if $Prio{$_} == -1 or not $Disp{$_};
    delete  $Disp{$Rstr{$_}} if $Rstr{$_};
    $Opts .= $Disp{$_}.' ';
  }
  return $Opts;
}

my sub TargetProc($$$) {
  my $Action    = shift;
  my $Opts      = shift;
  my $TargetReq = shift;
  my @Targets   = @ARGV; shift @Targets if @Targets and $Targets[0] eq '--';

  # Verify sufficient number of targets present:
  local $_ = $Action;
  undef $TargetReq if /^commit$/ and $Opts =~ /--amend/;
  if ($TargetReq) {
    SigHandler('MvDErr')    if /^mv$/ and scalar @Targets == 1;
    if (not @Targets) {
      SigHandler('CommErr') if /^revert$/;
      SigHandler('URLErr')  if /^clone$/;
      SigHandler('FileErr');
    }
  }

  # Edge-case handling:
  if (/^clone$/ and local $_ = $Targets[0]) {
    unless (m{^(?:\.)?/}) {
      my $Schema = 'https://'    if m{^(?!http(?:s)?://)};
      my $Host   = 'github.com'  if m{^%.*$};
      s/%/\//; $Targets[0] = $Schema.$Host.$_;
    }
  }
  elsif (/^rm$/ and $Opts =~ /(?<!--cached)-r(?!--cached)/) {
    print STDERR "+---------+\n| WARNING |\n+---------+";
    my $Confirm = '';
    until ($Confirm =~ /^(?:y|n|\n)$/i) {
      printf 'Confirm non-cached, recursive removal (y/N): ';
      $Confirm = <STDIN>;
    }
    SigHandler('SigInt') if $Confirm =~ /^(?:n)?\n$/i;
  }

  # Escape spaces:
  s/ /\\ /g foreach @Targets;
  return @Targets;
}


if (local $_ = shift) {
  if (/^a$/) {
    $Action = 'add';
    %Disp = (p => '--patch');
    %Prio = (p => -1);
  }
  elsif (/^c$/) {
    $Action = 'commit';
    %Disp = (a => '--amend', _1 => '');
    %Prio = (a => -1);
  }
  elsif (/^d$/) {
    $Action = 'diff';
    %Disp = (c => '--cached', _1 => '');
    %Prio = (c => -1);
  }
  elsif (/^f$/) { $NoProc = 'True'; $Action = 'fetch'; }
  elsif (/^l$/) {
    $Action = 'log';
    %Disp = (
      D => '--abbrev-commit',
      s => '--pretty=oneline',
      l => '--pretty=medium',
      n => '--name-only',
      _1 => '-4'
    );
    %Prio = (s => 2,    l => 1, n => -1,);
    %Rstr = (s => 'l',  l => 's');
  }
  # elsif (/^i$/) { $Action = 'init'; %Disp = (b => '--bare', _1 => 'master', _2 => '.'); }
  elsif (/^s$/) {
    $Action = 'status';
    %Disp = (s => '-s', l => '--long',  c => '--ahead-behind');
    %Prio = (s => 2,    l => 1,         c => -1);
    %Rstr = (s => 'l',  l => 's');
  }
  elsif (/^cl$/) { $Action = 'clone'; }
  elsif (/^mv$/) { $Action = 'mv'; }
  elsif (/^pl$/) {
    $Action = 'pull';
    %Disp = (n => '--no-rebase',  r => '--rebase');
    %Prio = (n => 2,              r => 1);
    %Rstr = (n => 'r',            r => 'n');
  }
  elsif (/^ps$/) { $NoProc = 'True'; $Action = 'push'; }
  elsif (/^rm$/) {
    $Action = 'rm';
    %Disp = (c => '--cached', n => ' ', r => '-r');
    %Prio = (c => 2,          n => 1,   r => -1);
    %Rstr = (c => 'n',        n => 'c');
  }
  elsif (/^res$/) {
    $Action = 'restore';
    %Disp = (s => '--staged', n => ' ');
    %Prio = (s => 2,          n => 1);
    %Rstr = (s => 'n',        n => 's');
  }
  elsif (/^rev$/) {
    $Action = 'revert';
    %Disp = (e => '-e', n => '--no-edit');
    %Prio = (e => 2,    n =>  1);
    %Rstr = (e => 'n',  n => 'e');
  }
  elsif (/^--$/) {
    Default();
  } else { SigHandler('ArgErr', $_); }

  if (not /^--$/) { # Generate @Args
    push(@Args, shift) until not @ARGV or $ARGV[0] eq '--';
  }

  unless ($NoProc) {
    $Opts     = OptProc($Action, %Disp, %Prio, %Rstr, @Args);
    @Targets  = TargetProc($Action, $Opts, $TargetReq);
  } else { $Opts = ''; @Targets = (); }
}   else { Default(); }


# Exception handling
# ------------------
unless ($Debug) {
  if ($Action eq 'status' and $Opts =~ /--ahead-behind/) {
    `git status --ahead-behind` =~ /(Your branch is .*\.)/;
    print $1; exit(0);
  }
}

# Build command string
# --------------------
my $Command = "git $Action $Opts -- @Targets"; $Command =~ s/\s+/ /g;

# Repository check
# ----------------
unless ($Debug or $Action =~ /^clone|init$/) {
  `git branch --show-current 2>/dev/null` or SigHandler('RepoErr');
}

# Debugging information / Git command execution
# ---------------------------------------------
if ($Debug) {
  $TargetReq or $TargetReq = 'False';
  $TargetOpt or $TargetOpt = 'False';
  print "Debug mode output:\n\nAction: $Action\nOpts:   $Opts\n";
  print "TargetReq: $TargetReq\nTargetOpt: $TargetOpt\nTarget(s):";
  print "    $_" foreach @Targets;
  print "\nGit command to be run:\n    $Command";
} else { system("$Command"); }
