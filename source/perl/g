#!/usr/bin/perl
use warnings;
use strict;

# NOTE:
#
# TODO:
# add -r option for git rm
# add git-diff as 'd'
# allow use of second '-m' for sub-messages

my $Author    = 'Nico Pareigis';
my ($Program) = $0 =~ m{^.*/(\w+)$};
my $Version   = '0.0.4';

sub Usage {
printf <<EOF
NAME
    $Program - shorthands for git commands

SYNOPSIS
    $Program [D] [OPTS] [-- FILES]

DESCRIPTION
    $Program aims to provide some useful shorthands for basic git operations. It
    doesn't aim to support all of git's features or functionality.
    Running $Program without any options runs 'git status' on either the entire
    repository, or on FILES, if any are specified.

OPTIONS
    D
      Run $Program in debug / dry-run mode. Print relevant information, but
      don't run the actual git command.

    [-]h
      Print this help information and exit.

    a -- FILES
      Run 'git add' on FILES.

    c ['commit msg' ['secondary commit msg']] -- FILES
      Run 'git commit' on FILES. Optionally takes one or two commit messages.
      The second commit message acts as if it were passed as a second '-m msg'
      to git.

      ---
      PROVIDING A SECONDARY COMMIT MESSAGE DOES NOT WORK YET!
      ---

    f
      Run 'git fetch' on the current repository.

    s [slc] [-- FILES]
      Run 'git status' on the current repository, or on FILES, if any are spe-
      cified. 's' (-s, default) and 'l' (--long) dictate the listing format. 'c'
      (as in 'commits') shows the branch's status compared to upstream.

    pl [nr]
      Run 'git pull' on the current repository. 'n' (--no-rebase, default) and
      'r' (--rebase) dictate whether or not git should rebase already commited
      changes.

    ps
      Run 'git push' on the current repository.

    re -- FILES
      Run 'git restore --staged' on staged FILES.

    rm [cn] [r] -- FILES
      Run 'git rm' on FILES. 'c' (--cached, default) and 'n' (as in 'not cached')
      dictate whether or not git should remove files only from the index, or if
      they should be completely removed from the disk. 'r' (-r) allows recursive
      removal of entire directory structures (USE WITH CAUTION!).

EXIT STATUS
    0, on success
    1, on argument error
    2, when missing filename(s)
    3, when trying to run outside of a git repository
    4, on dependency error

DEPENDENCIES
    git

VERSION
    $Version

AUTHOR(S)
    $Author
EOF
;
exit(0);
}

my sub Err {
  printf STDERR "Error: %s\n", $_[1];
  exit($_[0]) if $_[0] > 0;
}

my $Debug = '';
my $FilesRequired = '';
my sub SigHandler {
  Usage()                                     if $_[0] eq 'Usage';

  Err(1, 'Illegal argument - '.$_[1])         if $_[0] eq 'ArgErr';
  Err(2, 'No filename(s) specified!')         if $_[0] eq 'FileErr';
  Err(3, 'Not running in a git repository!')  if $_[0] eq 'RepoErr';
  Err(4, 'Dependency not met - '.$_[1])       if $_[0] eq 'DepErr';

  $Debug         = 'True', shift @ARGV        if $_[0] eq 'DebugMode';
  $FilesRequired = 'True'                     if $_[0] eq 'FilesReq';
}


# Dependency-, repo-, help-, debug mode, and required files checks
system('command -v git 1>/dev/null 2>&1') == 0
  or SigHandler('DepErr', 'git');
system('git branch --show-current 1>/dev/null 2>&1') == 0
  or SigHandler('RepoErr');
if (defined $ARGV[0]) {
  SigHandler('Usage')     if $ARGV[0] =~ /^((-)?h|--help|-\?)$/;
  SigHandler('DebugMode') if $ARGV[0] eq 'D';
}
SigHandler('FilesReq') if defined $ARGV[0] and $ARGV[0] =~ /[ac]|re|rm/;


# Argument processing
my $Action  = '';
my $Special = '';
my $Files   = '';

while (scalar @ARGV > 0) {
  if ($ARGV[0] =~ /^--$/) {
    shift;
    foreach (@ARGV) {
      $_ =~ s/ /\\ /;
      $Files = $Files.$_.' ';
    }
    $/ = ' '; chomp($Files);
    last;
  }

  elsif ($ARGV[0] =~ /^a$/) {
    $Action = 'add';
    shift;
  }

  elsif ($ARGV[0] =~ /^c$/) {
    # Err(12, 'Not properly implemented yet! Please refrain from using for the time being.');

    # /\w+\s+--(\s+\w+)+$/                        comm + file
    # /^\s*--(\s+\w+)+$/                          file
    # /^(\s*\w+)+$/                               comm
    # $String =~ /(\w+\s+)+\s+(--(?:\s+\w+)+)?$/; all
    # $String =~ /^(.*)\s+(--)/;                  old

    # if ($String =~ /^(\s*\w+)+(?:\s+--\s+.*)?/) { # needs alternative -- file
    # if ($String =~ /^\s*((?:'|")(?:.*)+(?:'|"))*\s+(--\s+.*)?/) {
    # if ($String =~ /^\s*((?:[^-])*)\s+(--\s+.*)?/) {

    $Action   = 'commit';
    shift;
    my $String  = join(' ', @ARGV);

    if ($String =~ /^(?:(.*)(?:\s+))?(--\s+.*)$/) {
      $Special = "-m '$1'" if $1;
      @ARGV = split(' ', "$2");
    }
    SigHandler('FileErr') if !$2;
  }

  elsif ($ARGV[0] =~ /^f$/) {
    $Action = 'fetch';
    last;
  }

  elsif ($ARGV[0] =~ /^s$/) {
    $Action   = 'status';
    $Special  = '-s';
    unless (!defined $ARGV[1]) {
      if ($ARGV[1] eq 's') {
        shift;
      }
      elsif ($ARGV[1] eq 'l') {
        $Special = '--long';
        shift;
      }
      elsif ($ARGV[1] eq 'c') {
        `git status --long --ahead-behind` =~ /(Your branch is .*\.)/;
        unless ($Debug) {
          printf $1."\n";
          exit(0);
        } else {
          $Special = 'Commit status.';
        }
        shift;
      }
    }
    shift;
  }

  elsif ($ARGV[0] =~ /^pl$/) {
    $Action   = 'pull';
    $Special  = '--no-rebase';
    unless (!defined $ARGV[1]) {
      if ($ARGV[1] eq 'n') {
        shift;
      }
      elsif ($ARGV[1] eq 'r') {
        shift;
        $Special = '--rebase';
      }
    }
    shift;
  }

  elsif ($ARGV[0] =~ /^ps$/) {
    $Action = 'push';
    last;
  }

  elsif ($ARGV[0] =~ /^re$/) {
    $Action   = 'restore';
    $Special  = '--staged';
    shift;
  }

  elsif ($ARGV[0] =~ /^rm$/) {
    $Action   = 'remove';
    $Special  = '--cached';
    unless (!defined $ARGV[1]) {
      if ($ARGV[1] eq 'c') {
        shift;
      }
      elsif ($ARGV[1] eq 'n') {
        $Special = '';
        shift;
      }

      if (defined $ARGV[1] and $ARGV[1] eq 'r') {
        $Special = $Special.' -r';
        shift;
      }
    }
    shift;
  }

  SigHandler('ArgErr', $ARGV[0]) if defined $ARGV[0] and $ARGV[0] ne '--';
}

# Set default $Action if no arguments were passed
$Action = 'status', $Special = '-s' if !$Action;

# Throw error if $Action requires files but none were passed
# or unset $Files if $Action doesn't require files but some were passed
if ($FilesRequired and !$Files) {
  SigHandler('FileErr');
}
if (!$FilesRequired and $Files) {
  $Files = '' unless $Action eq 'status';
}

# Print debugging information if running in debug / dry-run mode
if ($Debug) {
  printf "Debug mode output:\n\n";
  printf "Action:  $Action\nSpecial: $Special\nFiles:   $Files\n";
  exit(0);
}

system("git $Action $Special $Files");
