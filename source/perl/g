#!/usr/bin/perl
use warnings;
use strict;
$\ = "\n";

# potential issues preceeded by 'TODO' comments
# Issue:
#   * \ lost to shell interpretation - breaks filenames with spaces unless \\
#   * fix git-commit --amend targetreq limitation
#   * triple-exclusives don't work with optproc implementation
#
# Feature:
#   * consider reordering target processing and adding TargetProc
#
#   * git-clone --bare, --shallow, n name
#
#   * git-branch ('b')    -- list, create, delete
#   * git-checkout ('ch') -- switch commit
#   * git-init ('i(n)') (option for branch, bare, directory ($TargetOpt))
#     * needs exception to be run outside repo (see git-clone)
#   * git-merge ('m')     -- --abort, --continue
#   * git-switch ('sw')   -- switch branch
#   * git-stash 'st'

my $Author    = 'Nico Pareigis';
my ($Program) = $0 =~ m{^.*/(.+)$};
my $Version   = '0.1.4';

sub D {
  return "    D
      Run $Program in debug mode. Print relevant information to STDOUT, but
      don't run the actual git command.\n";
}
sub h {
  return "    [-]h [OPT]
      Print help information and exit.
      When passed a valid option name as the first parameter, only print infor-
      mation concerning that option. Subsequent parameters are discarded.\n";
}
sub a {
  return "    a [p] -- FILE...
      Run 'git add' on FILE... .
      'p' (--patch) allows patching only specific hunks.\n";
}
sub c {
  return "    c [a] ['commit msg' [%% 'secondary commit msg']] -- FILE...
      Run 'git commit' on FILE... .
      'a' (--amend) amends the latest commit's commit message.
      Optionally takes one or two commit messages, where '%%' acts as a sepa-
      rator between the two. The second commit message is passed as a second
      '-m ...' to git.
      NOTE: double dashes in commit mesages must not be used!\n";
}
sub d {
  return "    d [c] [COMMIT...] [-- FILE...]
      Run 'git diff' on the repository, COMMIT... and/or FILE... .
      'c' (--cached) allows comparisons between HEAD and the index.

      SYNOPSIS
        '$Program d COMMIT...'  runs on COMMIT... .
        '$Program d -- FILE...' runs on FILE... .
        '$Program d COMMIT... -- FILE...' runs on the commit(s) with hash
        COMMIT... on FILE..., if such a commit exists for FILE... .\n";
}
sub f {
  return "    f
      Run 'git fetch' on the current repository.\n";
}
sub l {
  return "    l [sl] [n] [INT] [-- FILE...]
      Run 'git log --abbrev-commit' on the current repository, or on FILE...,
      if any are specified. As normal, subsequent files are ignored. 's' (as in
      'short' (i.e. --pretty=oneline), default) and 'l' (as in 'long'
      (i.e. --pretty=medium)) dictate the listing format.
      'n' (--name-only) dictates whether or not the filenames belonging to com-
      mits should be shown.
      Optionally takes an integer to specify the number of commits to show (de-
      fault is 4).\n";
}
sub _s {
  return "    s [sl] [c] [-- FILE...]
      Run 'git status' on the current repository, or on FILE..., if any are spe-
      cified.
      's' (-s, default) and 'l' (--long) dictate the listing format.
      'c' (as in 'compare') shows the branch's status compared to upstream.\n";
}
sub cl {
  return "    cl -- URL
      Clone the repository located at URL.
      Omitting the URL schema assumes https. A URL starting with a percent sign
      (%) is assumed to refer to a github repository - access is done via https.
      Local repositories may be cloned with either relative, or absolute URLs.

      SYNOPSIS
        '$Program cl -- https://github.com/user/repo',
        '$Program cl -- github.com/user/repo'
        and '$Program cl -- %user/repo',
        will all clone the same repository at 'https://github.com/user/repo'\n";
}
sub mv {
  return "    mv -- SOURCE... DEST
      Rename SOURCE... to DEST | DEST/SOURCE... and add the renamed files to the
      index.\n";
}
sub pl {
  return "    pl [nr]
      Run 'git pull' on the current repository.
      'n' (--no-rebase, default) and 'r' (--rebase) dictate whether or not git
      should rebase already commited changes.\n";
}
sub ps {
  return "    ps
      Run 'git push' on the current repository.\n";
}
sub rm {
  return "    rm [cn] [r] -- FILE...
      Run 'git rm' on FILE... .
      'c' (--cached, default) and 'n' (as in 'not cached') dictate whether or
      not git should remove files only from the index, or if they should be com-
      pletely removed from the disk.
      'r' (-r) allows recursive removal of entire directory structures.\n";
}
sub res {
  return "    res [sn] -- FILE...
      Run 'git restore' on FILE... .
      's' (--staged, default) and 'n' (as in 'not staged') dictate whether the
      contents should be restored from HEAD or from the index.\n";
}
sub rev {
  return "    rev [en] -- COMMIT...
      Run 'git revert' on COMMIT... .
      'e' (-e, default) and 'n' (--no-edit) dictate whether or not the commit me-
      ssage may be changed before the commit is reverted.\n";
}

my %Help = (
  D => D(), h => h(), a => a(), c => c(),
  d => d(), f => f(), l => l(), s => _s(),
  cl => cl(), mv => mv(), pl => pl(), ps => ps(),
  rm  => rm(),
  res => res(), rev => rev()
);

sub Help {
print <<EOF
NAME
    $Program - shorthands for git commands

SYNOPSIS
    $Program [D] [OPTS [SUBOPTS]] [-- FILE...|COMMIT...|URL]

DESCRIPTION
    $Program aims to provide some useful shorthands for basic git operations. It
    doesn't try to support all of git's features or functionality.
    Running $Program without any options runs 'git status -s' on the repository.

    $Program currently provides shorthands for the following commands:
    add, clone, commit, diff, fetch, log, mv, pull, push, rm, restore, revert,
    status

OPTIONS
$Help{D}\n$Help{h}\n$Help{a}\n$Help{c}
$Help{d}\n$Help{f}\n$Help{l}\n$Help{s}
$Help{cl}\n$Help{mv}\n$Help{pl}\n$Help{ps}
$Help{rm}
$Help{res}\n$Help{rev}
EXIT STATUS
    0, on success
    1, on argument error
    2, when missing filename or similar
    3, when trying to run outside of a git repository
    4, on dependency error
  130, on specific user action

DEPENDENCIES
    git

VERSION
    $Version

AUTHOR(S)
    $Author
EOF
; exit(0);
}

my sub Err {
  printf STDERR "Error: %s\n", $_[1];
  exit($_[0]) if $_[0] > 0;
}

my $Debug     = '';
my @Optional  = ('l', 's', 'd');
my @Requires  = ('a', 'c', 'cl', 'mv', 'rm', 'res', 'rev');
my $TargetOpt = ''; my $TargetReq = '';

my sub SigHandler {
  local $_ = shift;
  Err(1, 'No help available - '.$_[0])        if /HelpErr/;
  Err(1, 'Illegal argument - '.$_[0])         if /ArgErr/;

  Err(2, 'No commit specified!')              if /CommErr/;
  Err(2, 'Nothing to debug!')                 if /DebugErr/;
  Err(2, 'No filename specified!')            if /FileErr/;
  Err(2, 'Missing destination!')              if /MvDErr/;
  Err(2, 'No URL specified!')                 if /URLErr/;

  Err(3, 'Not running in a git repository!')  if /RepoErr/;
  Err(4, 'Dependency not met - '.$_[0])       if /DepErr/;

  Err(130, 'Execution interrupted by user action.') if /UserAction/;

  do {$Debug = 'True'; shift @ARGV} if /DebugMode/;
}


# Preliminary checks
# ------------------
# Dependencies
`git -v 2>/dev/null` or SigHandler('DepErr', 'git');

# Help, Debug, Requires / Optional
if (local $_ = $ARGV[0]) {
  if (/^(?:(-)?h|--help|-\?)$/) {
    do {Help(); exit(0)}            if not $ARGV[1];
    SigHandler('HelpErr', $ARGV[1]) if not $Help{$ARGV[1]};
    print "$Help{$ARGV[1]}"; exit(0);
  }

  SigHandler('DebugMode')     if /^D$/;
  SigHandler('DebugErr')      if $Debug and not $ARGV[0];

  foreach (@Requires) {do {$TargetReq = 'True'; last} if /^$ARGV[0]$/};
  foreach (@Optional) {do {$TargetOpt = 'True'; last} if /^$ARGV[0]$/};
}


# Option processing
# -----------------
my $Action; my @Args; my $NoProc;
my %Disp = (); my %Prio     = (); my %Rstr = ();
my $Opts = ''; my @Targets  = ();

my sub Default() {
  $Action = 'status';
  $Opts = '-s';
}

my sub OptProc($\%\%\%\@) {
  my $Action  = shift; # action
  my $rDisp   = shift; # dispatch table
  my $rPrio   = shift; # priority hash
  my $rRstr   = shift; # restrict hash
  my $rArgs   = shift; # arguments
  my %Disp = %$rDisp; my %Prio = %$rPrio;
  my %Rstr = %$rRstr; my @Args = @$rArgs;
  undef $rDisp; undef $rPrio; undef $rRstr; undef $rArgs;

  my sub DynProc() {
    return (1, '-'.$_) if $Action eq 'log' and $Disp{_1} eq '-4' and /^\d+$/;

    if ($Action eq 'diff' and $Disp{_1} eq '') {
      unshift(@Args, $_); my $Commits = join(' ', @Args); undef @Args;
      return(1, $Commits);
    }

    if ($Action eq 'commit' and $Disp{_1} eq '') {
      my $Msg1; my $Msg2;
      unshift(@Args, $_); s/"/\\"/g foreach @Args;
      join(' ', @Args) =~ /^(.*?)(?:\s+%%\s+(.*?))?$/;
      $1 and $Msg1 = "-m \"$1\"" or $Msg1 = '';
      $2 and $Msg2 = "-m \"$2\"" or $Msg2 = '';
      undef @Args;
      return (1, $Msg1.' '.$Msg2);
    }

    return undef;
  } # ------------------------------

  my sub PrioSort(\%) {
    my $Hash = shift; $Prio{(%$Hash)[0]} = 0 if scalar %$Hash == 1;
    sort
    { $Prio{$a} = 9 if $a eq 'D';     $Prio{$b} = 9 if $b eq 'D';
      $Prio{$a} = 0 if not $Prio{$a}; $Prio{$b} = 0 if not $Prio{$b};
      return -1 * ($Prio{$a} <=> $Prio{$b});
    } keys %$Hash;
  } # ------------------------------

  while (local $_ = shift @Args) {
    if ($Disp{$_}) { # processes static options
      $Opts .= $Disp{$_}.' ';
      delete $Disp{$_};
      delete $Disp{$Rstr{$_}} if $Rstr{$_};
    }
    else { # processes dynamic option
      my ($K, $V) = DynProc;
      $K and $Disp{'_'.$K} = $V or SigHandler('ArgErr', $_);
    }
  }

  foreach (PrioSort %Disp) {
    next if $Prio{$_} == -1 or not $Disp{$_};
    delete  $Disp{$Rstr{$_}} if $Rstr{$_};
    $Opts .= $Disp{$_}.' ';
  }
}

if (local $_ = shift) {
  if (/^a$/) {
    $Action = 'add';
    %Disp = (p => '--patch');
    %Prio = (p => -1);
  }

  elsif (/^c$/) {
    $Action = 'commit';
    %Disp = (a => '--amend', _1 => '');
    %Prio = (a => -1);
  }

  elsif (/^d$/) {
    $Action = 'diff';
    %Disp = (c => '--cached', _1 => '');
    %Prio = (c => -1);
  }

  elsif (/^f$/) { $NoProc = 'True'; $Action = 'fetch'; }

  elsif (/^l$/) {
    $Action = 'log';
    %Disp = (
      D => '--abbrev-commit',
      s => '--pretty=oneline',
      l => '--pretty=medium',
      n => '--name-only',
      _1 => '-4'
    );
    %Prio = (s => 2,    l => 1, n => -1,);
    %Rstr = (s => 'l',  l => 's');
  }

  # elsif (/^i$/) { $Action = 'init'; %Disp = (b => '--bare', _1 => 'master', _2 => '.'); }

  elsif (/^s$/) {
    $Action = 'status';
    %Disp = (s => '-s', l => '--long',  c => '--ahead-behind');
    %Prio = (s => 2,    l => 1,         c => -1);
    %Rstr = (s => 'l',  l => 's');
  }

  elsif (/^cl$/) { $Action = 'clone'; }

  elsif (/^mv$/) { $Action = 'mv'; }

  elsif (/^pl$/) {
    $Action = 'pull';
    %Disp = (n => '--no-rebase',  r => '--rebase');
    %Prio = (n => 2,              r => 1);
    %Rstr = (n => 'r',            r => 'n');
  }

  elsif (/^ps$/) { $NoProc = 'True'; $Action = 'push'; }

  elsif (/^rm$/) {
    $Action = 'rm';
    %Disp = (c => '--cached', n => ' ', r => '-r');
    %Prio = (c => 2,          n => 1,   r => -1);
    %Rstr = (c => 'n',        n => 'c');
  }

  elsif (/^res$/) {
    $Action = 'restore';
    %Disp = (s => '--staged', n => ' ');
    %Prio = (s => 2,          n => 1);
    %Rstr = (s => 'n',        n => 's');
  }

  elsif (/^rev$/) {
    $Action = 'revert';
    %Disp = (e => '-e', n => '--no-edit');
    %Prio = (e => 2,    n =>  1);
    %Rstr = (e => 'n',  n => 'e');
  }

  elsif (/^--$/) {
    Default();
    @Targets = @ARGV[0..$#ARGV];
  } else { SigHandler('ArgErr', $_); }

  # Generate @Args and @Targets
  if (not /^--$/) {
    until (not @ARGV or $ARGV[0] =~ /^--$/) {
      push(@Args, shift);
    }
    @Targets = @ARGV[1..$#ARGV];
  }

} else { Default(); }

OptProc($Action, %Disp, %Prio, %Rstr, @Args) unless $NoProc;


# Exception handling
# ------------------
unless ($Debug) {
  if ($Action eq 'status' and $Opts =~ /--ahead-behind/) {
    `git status --ahead-behind` =~ /(Your branch is .*\.)/;
    print $1; exit(0);
  }
}

# Target processing
# -----------------
if ($Action eq 'clone' and local $_ = $Targets[0]) {
  unless (m{^(?:\.)?/}) {
    my $Schema = 'https://'    if m{^(?!http(?:s)?://)};
    my $Host   = 'github.com'  if m{^%(.*)$};
    s/%/\//; $Targets[0] = $Schema.$Host.$_;
  }
}
elsif ($Action eq 'rm' and $Opts =~ /(?<!--cached)-r(?!--cached)/) {
  print STDERR 'WARNING';
  my $Confirm = '';
  until ($Confirm =~ /^(?:y|n|\n)$/i) {
    printf 'Confirm non-cached, recursive removal (y/N): ';
    $Confirm = <STDIN>;
  }
  SigHandler('UserAction') if $Confirm =~ /^(?:n)?\n$/i;
}

if ($TargetReq) {
  local $_ = $Action;
  SigHandler('MvDErr')    if /^mv$/ and scalar @Targets == 1;
  if (not @Targets) {
    SigHandler('CommErr') if /^revert$/;
    SigHandler('URLErr')  if /^clone$/;
    SigHandler('FileErr');
  }
}
my $Targets = '';
do { s/ /\\ /; $Targets .= $_.' '; } foreach @Targets;
local $/ = ' '; chomp($Targets);


# Build command string and replace double whitespace
# --------------------------------------------------
my $Command = "git $Action $Opts -- $Targets"; $Command =~ s/\s+/ /g;


# Repository check
# ----------------
unless ($Debug or $Action =~ /^clone|init$/) {
  `git branch --show-current 2>/dev/null` or SigHandler('RepoErr');
}


# Debugging information / Git command execution
# ---------------------------------------------
if ($Debug) {
  $TargetReq = 'False' if not $TargetReq;
  $TargetOpt = 'False' if not $TargetOpt;
  print "Debug mode output:\n\nAction: $Action\nOpts:   $Opts\n";
  print "TargetRequired: $TargetReq\nTargetOptional: $TargetOpt\nTarget(s):";
  foreach (@Targets) {
    print "    $_";
  }
  print "\nGit command to be run:\n    $Command";
} else { system("$Command"); }
