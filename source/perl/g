#!/usr/bin/perl
use warnings;
use strict;

# NOTE:
# Shell command execution:
#   Concatenating to string may be less efficient than in-place replacement of
#   whitespace (i.e. C-style for).
#
# Issue:
#   Consider updating error handling for shell execution errors
#   E.g.: git-diff throws long error message with '-' as last argument
#   Drawback: Tons of work, needs testing for heaps of edge cases for every command
#
# TODO:
# High Prio.:
#   add git-init as 'i(n)' (option for branch, bare, directory ($TargetOpt))
#   add git-switch as 'sw'
#   add git-merge as 'm'
#
#   add git-branch ('b')    -- list, create, delete
#   add git-switch ('sw')   -- switch branch
#   add git-checkout ('ch') -- switch commit
#
#   add git-commit --amend if possible
#
# Low Prio.:
#   add git-stash as 'st'

my $Author    = 'Nico Pareigis';
my ($Program) = $0 =~ m{^.*/(\w+)$};
my $Version   = '0.1.3';

sub Usage {
printf <<EOF
NAME
    $Program - shorthands for git commands

SYNOPSIS
    $Program [D] [OPTS [SUBOPTS]] [-- FILE...|COMMIT...|URL]

DESCRIPTION
    $Program aims to provide some useful shorthands for basic git operations. It
    doesn't try to support all of git's features or functionality.
    Running $Program without any options runs 'git status -s' on the repository.

    $Program currently provides shorthands for the following commands:
    add, clone, commit, diff, fetch, log, mv, pull, push, rm, restore, revert,
    status

OPTIONS
    D
      Run $Program in debug mode. Print relevant information to STDOUT, but
      don't run the actual git command.

    [-]h
      Print this help information and exit.

    a -- FILE...
      Run 'git add' on FILE... .

    c ['commit msg' [%%%% 'secondary commit msg']] -- FILE...
      Run 'git commit' on FILE... .
      Optionally takes one or two commit messages, where '%%%%' acts as a sepa-
      rator between the two. The second commit message is passed as a second
      '-m ...' to git.
      NOTE: double dashes in commit mesages must not be used!

    d [COMMIT...] [-- FILE...]
      Run 'git diff' on the repository, COMMIT..., or FILE... .

      SYNOPSIS
        '$Program d COMMIT...'  runs on COMMIT... .
        '$Program d -- FILE...' runs on FILE... .
        '$Program d COMMIT... -- FILE...' runs on the commit(s) with hash
        COMMIT... on FILE..., if such a commit exists for FILE... .

    f
      Run 'git fetch' on the current repository.

    l [sl] [n] [INT] [-- FILE...]
      Run 'git log --abbrev-commit --no-decorate' on the current repository, or
      on FILE..., if any are specified. As normal, subsequent files are ignored.
      's' (as in 'short' (i.e. --pretty=oneline), default) and 'l' (as in 'long'
      (i.e. --pretty=medium) dictate the listing format. 'n' (--name-only) dic-
      tates whether or not the filenames belonging to commits should be shown.
      Optionally takes an integer to specify the number of commits to show (de-
      fault is 4).

    r [en] -- COMMIT...
      Run 'git revert' on COMMIT... .
      'e' (-e, default) and 'n' (--no-edit) dictate whether or not the commit me-
      ssage may be changed before the commit is reverted.

    s [slc] [-- FILE...]
      Run 'git status' on the current repository, or on FILE..., if any are spe-
      cified.
      's' (-s, default) and 'l' (--long) dictate the listing format. 'c' (as in
      'compare') shows the branch's status compared to upstream.

    cl -- URL
      Clone the repository located at URL.
      Omitting the URL schema assumes https. A URL starting with a leading slash
      is assumed to refer to a github repository - access is done via https.

      SYNOPSIS
        '$Program cl -- https://github.com/user/repo',
        '$Program cl -- github.com/user/repo'
        and '$Program cl -- /user/repo',
        will all clone the same repository at 'https://github.com/user/repo'

    mv -- SOURCE... DEST
      Rename SOURCE... to DEST | DEST/SOURCE... and add the renamed files to the
      index.

    pl [nr]
      Run 'git pull' on the current repository.
      'n' (--no-rebase, default) and 'r' (--rebase) dictate whether or not git
      should rebase already commited changes.

    ps
      Run 'git push' on the current repository.

    re -- FILE...
      Run 'git restore --staged' on staged FILE... .

    rm [cn] [r] -- FILE...
      Run 'git rm' on FILE... .
      'c' (--cached, default) and 'n' (as in 'not cached') dictate whether or
      not git should remove files only from the index, or if they should be com-
      pletely removed from the disk. 'r' (-r) allows recursive removal of entire
      directory structures (USE WITH CAUTION!).

EXIT STATUS
    0, on success
    1, on argument error
    2, when missing filename or similar
    3, when trying to run outside of a git repository
    4, on dependency error

DEPENDENCIES
    git

VERSION
    $Version

AUTHOR(S)
    $Author
EOF
;
exit(0);
}

my sub Err {
  printf STDERR "Error: %s\n", $_[1];
  exit($_[0]) if $_[0] > 0;
}

my $Debug = '';
my @Optional  = ( 'l', 's', 'd');
my @Requires  = ( 'a', 'c', 'r', 'cl', 'mv', 're', 'rm',);
my $TargetOpt = '';
my $TargetReq = '';

my sub SigHandler {
  Usage()                                     if $_[0] eq 'Usage';

  Err(1, 'Illegal argument - '.$_[1])         if $_[0] eq 'ArgErr';

  Err(2, 'No commit specified!')              if $_[0] eq 'CommErr';
  Err(2, 'Nothing to debug!')                 if $_[0] eq 'DebugErr';
  Err(2, 'No filename specified!')            if $_[0] eq 'FileErr';
  Err(2, 'Missing destination!')              if $_[0] eq 'MvDErr';
  Err(2, 'No URL specified!')                 if $_[0] eq 'URLErr';

  Err(3, 'Not running in a git repository!')  if $_[0] eq 'RepoErr';
  Err(4, 'Dependency not met - '.$_[1])       if $_[0] eq 'DepErr';

  $Debug = 'True', shift @ARGV if $_[0] eq 'DebugMode';
}


# Dependency check
system('command -v git 1>/dev/null 2>&1') == 0
  or SigHandler('DepErr', 'git');

# Help-, debug-mode-, target-required-checks
if (defined $ARGV[0]) {
  SigHandler('Usage')         if $ARGV[0] =~ /^((-)?h|--help|-\?)$/;
  SigHandler('DebugMode')     if $ARGV[0] =~ /^D$/;

  SigHandler('DebugErr') if $Debug and !defined $ARGV[0];

  foreach (@Requires) {
    $TargetReq = 'True' if $ARGV[0] =~ /^$_$/;
  }
  foreach (@Optional) {
    $TargetOpt = 'True' if $ARGV[0] =~ /^$_$/;
  }
}

# Repository check
unless ($Debug or (defined $ARGV[0] and $ARGV[0] =~ /^cl$/)) {
  system('git branch --show-current 1>/dev/null 2>&1') == 0
    or SigHandler('RepoErr');
}


# Argument processing
my $Action  = '';
my $Options = '';
my @Targets = ();

while (scalar @ARGV > 0) {
  if ($ARGV[0] =~ /^--$/) {
    shift;
    @Targets = @ARGV;
    last;
  }

  elsif ($ARGV[0] =~ /^a$/) {
    $Action = 'add';
    shift;
  }

  elsif ($ARGV[0] =~ /^c$/) {
    $Action       = 'commit';
    shift;

    my $PrmMsg  = '';
    my $SubMsg  = '';

    $_ =~ s/"/\\"/g foreach @ARGV;
    my $String  = join(' ', @ARGV);
    if ($String =~ /^(?:(.*?)(?:\s+%%\s+(.*?))?\s+)?(--\s+.*)$/) {
      $PrmMsg  = '-m '."\"$1\""   if $1;
      $SubMsg  = ' -m '."\"$2\""  if $2;

      $Options = $PrmMsg.$SubMsg;
      undef $PrmMsg;
      undef $SubMsg;
      @ARGV = split(' ', $3);
      next;
    }

    # Required in case commit message is present but no files are passed.
    SigHandler('FileErr');
  }

  elsif ($ARGV[0] =~ /^d$/) {
    $Action       = 'diff';
    shift;

    # my $String = join(' ', @ARGV); if ($String =~ /^([0-9a-f]{7}(?:[0-9a-f]{33})?(?:\s+[0-9a-f]{7}(?:[0-9a-f]{33})?)*)?(?:\s+(--\s+.*))?$/) { $Options = $1 if $1; undef $Commits, last if !$2; @ARGV = split(' ', $2) if $2; }

    while (defined $ARGV[0] and $ARGV[0] ne '--') {
      $Options = $Options.' '.$ARGV[0];
      shift;
    }
  }

  elsif ($ARGV[0] =~ /^f$/) {
    $Action = 'fetch';
    last;
  }

  elsif ($ARGV[0] =~ /^l$/) {
    $Action       = 'log';
    $Options      = '--abbrev-commit --no-decorate --pretty=';
    my $Display   = 'oneline';
    my $Count     = ' -4';
    my $Name      = '';

    if (defined $ARGV[1]) {
      if ($ARGV[1] =~ /^s$/) {
        shift;
      }
      elsif ($ARGV[1] =~ /^l$/) {
        $Display = 'medium';
        shift;
      }

      if (defined $ARGV[1] and $ARGV[1] =~ /^n$/) {
        $Name = ' --name-only';
        shift;
      }

      if (defined $ARGV[1] and $ARGV[1] =~ /^[1-9][0-9]*$/) {
        $Count = ' -'.$ARGV[1];
        shift;
      }
    }

    $Options = $Options.$Display.$Count.$Name;
    undef $Display;
    undef $Count;
    undef $Name;
    shift;
  }

  elsif ($ARGV[0] =~ /^r$/) {
    $Action   = 'revert';
    $Options  = '-e';

    if (defined $ARGV[1]) {
      if ($ARGV[1] =~ /^e$/) {
        shift;
      }
      elsif ($ARGV[1] =~ /^n$/) {
        $Options = '--no-edit';
        shift;
      }
    }
    shift;
  }

  elsif ($ARGV[0] =~ /^s$/) {
    $Action   = 'status';
    $Options  = '-s';

    if (defined $ARGV[1]) {
      if ($ARGV[1] =~ /^s$/) {
        shift;
      }
      elsif ($ARGV[1] =~ /^l$/) {
        $Options = '--long';
        shift;
      }
      elsif ($ARGV[1] =~ /^c$/) {
        $Options = '--ahead-behind';
        shift;

        unless ($Debug) {
          SigHandler('ArgErr', $ARGV[1])
            if defined $ARGV[1] and $ARGV[1] ne '--';

          `git $Action $Options` =~ /(Your branch is .*\.)/;
          printf $1."\n";
          exit(0);
        }
      }
    }
    shift;
  }

  elsif ($ARGV[0] =~ /^cl$/) {
    $Action = 'clone';
    shift;
  }

  elsif ($ARGV[0] =~ /^mv$/) {
    $Action = 'mv';
    shift;
  }

  elsif ($ARGV[0] =~ /^pl$/) {
    $Action   = 'pull';
    $Options  = '--no-rebase';

    if (defined $ARGV[1]) {
      if ($ARGV[1] =~ /^n$/) {
        shift;
      }
      elsif ($ARGV[1] =~ /^r$/) {
        shift;
        $Options = '--rebase';
      }
    }
    last;
  }

  elsif ($ARGV[0] =~ /^ps$/) {
    $Action = 'push';
    last;
  }

  elsif ($ARGV[0] =~ /^re$/) {
    $Action   = 'restore';
    $Options  = '--staged';
    shift;
  }

  elsif ($ARGV[0] =~ /^rm$/) {
    $Action   = 'rm';
    $Options  = '--cached';

    if (defined $ARGV[1]) {
      if ($ARGV[1] =~ /^c$/) {
        shift;
      }
      elsif ($ARGV[1] =~ /^n$/) {
        $Options = '';
        shift;
      }

      if (defined $ARGV[1] and $ARGV[1] =~ /^r$/) {
        $Options = $Options.' -r';
        shift;
      }
    }
    shift;
  }

  SigHandler('ArgErr', $ARGV[0]) if defined $ARGV[0] and $ARGV[0] ne '--';
}


# Set default $Action if no arguments were passed
$Action = 'status', $Options = '-s' if !$Action;


# Throw error if $Action requires targets but none / too few were passed
if ($TargetReq) {
  if (!@Targets) {
    SigHandler('CommErr') if $Action eq 'revert';
    SigHandler('URLErr')  if $Action eq 'clone';
    SigHandler('FileErr');
  }
  SigHandler('MvDErr') if $Action eq 'mv' and scalar @Targets == 1;
}


# Target processing
my $Targets = '';

if ($Action eq 'clone') {
  my $Schema  = '';
  my $Host    = '';
  $Schema = 'https://'    if $Targets[0] !~ m{^http(s)?://};
  $Host   = 'github.com'  if $Targets[0] =~ m{^/.*$};

  $Targets[0] = $Schema.$Host.$Targets[0];
}

foreach (@Targets) {
  $_ =~ s/ /\\ /;
  $Targets = $Targets.$_.' ';
}
$/ = ' '; chomp($Targets);


# Build command string and replace double whitespace
my $Command = "git $Action $Options -- $Targets";
$Command =~ s/\s\s/ /g;


# Print debugging information when running in debug mode
if ($Debug) {
  $TargetReq = 'False' if !$TargetReq;
  $TargetOpt = 'False' if !$TargetOpt;

  printf "Debug mode output:\n\n";
  printf "Action:  $Action\nOptions: $Options\n\n";
  printf "TargetRequired: $TargetReq\nTargetOptional: $TargetOpt\nTarget(s):\n";

  foreach (@Targets) {
    printf "    $_\n";
  }

  printf "\nGit command to be run:\n    $Command\n";
  exit(0);
}


# Git command execution
system("$Command");
