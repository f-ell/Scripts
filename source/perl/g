#!/usr/bin/perl
use warnings;
use strict;
$\ = "\n";

# potential issues preceeded by 'TODO' comments
# Issue:
#   * sort %Help keys and loop over in full help or:
#   * maintain List containing subrefs in order and loop over
#     * needs adapting to individual help calls for single option
#
# Feature:
#   * git-checkout ('ch') -- switch commit

my $Author    = 'Nico Pareigis';
my ($Program) = $0 =~ m{^.*/(.+)$};
my $Version   = '0.1.4';

my sub Err {
  printf STDERR "Error: %s\n", $_[1];
  exit($_[0]) if $_[0] > 0;
}
my sub SigHandler {
  local $_ = shift;
  Err(  1, 'No help available - '.$_[0])  if /^HelpErr$/;
  Err(  1, 'Illegal argument - '.$_[0])   if /^ArgErr$/;
  Err(  2, 'Missing branch name!')        if /^BranchErr$/;
  Err(  2, 'Missing commit!')             if /^CommErr$/;
  Err(  2, 'Nothing to debug!')           if /^DebugErr$/;
  Err(  2, 'Missing filename!')           if /^FileErr$/;
  Err(  2, 'Missing destination!')        if /^MvDErr$/;
  Err(  2, 'Missing URL!')                if /^URLErr$/;
  Err(  3, 'Not in a git repository!')    if /^RepoErr$/;
  Err(  4, 'Dependency not met - '.$_[0]) if /^DepErr$/;
  Err(130, 'Interrupt received!')         if /^SigInt$/;
}
$SIG{INT}   = sub { SigHandler('SigInt'); };
$SIG{TERM}  = sub { SigHandler('SigInt'); };

my sub D {
  return "    D
      Run $Program in debug mode. Print relevant information to STDOUT, but
      don't run the actual git command.\n";
}
my sub h {
  return "    [-]h [OPT]
      Print help information and exit.
      When passed a valid option name as the first parameter, only print infor-
      mation concerning that option. Subsequent parameters are discarded.\n";
}
my sub a {
  return "    a [p] -- FILE...
      Run 'git add' on FILE... .
        'p' => --patch\n";
}
my sub b {
  return "    b [cdlm] [-- BRANCH...]
      Run 'git branch' on BRANCH.
        'c' => -c
        'd' => -d
        'l' => --list, default
        'm' => -m\n";
}
my sub c {
  return "    c [a] ['commit msg' [%% 'secondary commit msg']] -- FILE...
      Run 'git commit' on FILE... .
        'a' => --amend

      Optionally takes one or two commit messages, where '%%' acts as a sepa-
      rator between the two. The second commit message is passed as a submes-
      sage to git.
      NOTE: double dashes in commit mesages will break parsing!\n";
}
my sub d {
  return "    d [c] [COMMIT...] [-- FILE...]
      Run 'git diff' on the repository, COMMIT... and/or FILE... .
        'c' => --cached\n";
}
my sub f {
  return "    f
      Run 'git fetch' on the current repository.\n";
}
my sub i {
  return "    i [b] [BRANCH] [-- DIR]
      Run 'git init' on the current directory or DIR.
        'b' => --bare

      Optionally uses BRANCH as the initial branch name, instead of the default
      name 'master'.\n";
}
my sub l {
  return "    l [ls] [n] [INT] [-- FILE...]
      Run 'git log --abbrev-commit' on the current repository, or on FILE... .
        'l' => --pretty=medium
        's' => --pretty=oneline, default
        'n' => --name-only

      Optionally takes an integer to specify the number of commits to show (de-
      fault is 4).\n";
}
my sub _m {
  return "    m [acq] [-- BRANCH]
      Run 'git merge' on BRANCH.
        'a' => --abort
        'c' => --continue
        'q' => --quit\n";
}
my sub _s {
  return "    s [ls] [c] [-- FILE...]
      Run 'git status' on the current repository, or on FILE... .
        'l' => --long
        's' => -s, default
        'c' => --ahead-behind\n";
}
my sub cl {
  return "    cl [INT] -- URL [DIR]
      Clone the repository located at URL to DIR.

      Optionally takes an integer to specify the clone depth.

      Omitting the URL schema assumes https. A URL starting with a percent sign
      (%) is assumed to refer to a github repository. Local repositories may be
      cloned with both relative and absolute URLs.

      '$Program cl -- [https://]github.com/user/repo | %user/repo'
      will try to clone a repository at 'https://github.com/user/repo'\n";
}
my sub mv {
  return "    mv -- SOURCE... DEST
      Run 'git mv' on SOURCE... DEST.\n";
}
my sub pl {
  return "    pl [nr]
      Run 'git pull' on the current repository.
        'n' => --no-rebase, default
        'r' => --rebase\n";
}
my sub ps {
  return "    ps
      Run 'git push' on the current repository.\n";
}
my sub rm {
  return "    rm [cn] [r] -- FILE...
      Run 'git rm' on FILE... .
        'c' => --cached, default
        'n' => not --cached
        'r' => -r\n";
}
my sub st {
  return "    st [clous] [-- FILE...]
      Run 'git stash' on FILE... .
        'c' => clear
        'l' => list
        'o' => pop
        'u' => push
        's' => show\n";
}
my sub sw {
  return "    sw -- BRANCH
      Run 'git switch' on BRANCH.\n";
}
my sub res {
  return "    res [ns] -- FILE...
      Run 'git restore' on FILE... .
        'n' => not --staged
        's' => --staged, default\n";
}
my sub rev {
  return "    rev [en] -- COMMIT...
      Run 'git revert' on COMMIT... .
        'e' => -e, default
        'n' => --no-edit\n";
}

my %Help = (
  D => D(), h => h(), a => a(), b => b(), c => c(), d => d(), f => f(),
  i => i(), l => l(), m => _m(), s => _s(),
  cl => cl(), mv => mv(), pl => pl(), ps => ps(),
  rm => rm(), st => st(), sw => sw(),
  res => res(), rev => rev()
);
sub Help {
print <<EOF
NAME
    $Program - shorthands for git commands

SYNOPSIS
    $Program [D] [OPT [SUBOPTS]] [-- BRANCH|COMMIT...|FILE...|URL]

DESCRIPTION
    $Program aims to provide some useful shorthands for basic git operations. It
    doesn't try to support all of git's features or functionality.
    Running $Program without any options runs 'git status -s' on the repository.

    $Program currently provides shorthands for the following commands:
    add, branch, clone, commit, diff, fetch, init, log, merge, mv, pull, push,
    rm, restore, revert, stash, status, switch

OPTIONS
$Help{D}\n$Help{h}\n$Help{a}\n$Help{b}\n$Help{c}\n$Help{d}\n$Help{f}\n$Help{i}
$Help{l}\n$Help{m}\n$Help{s}
$Help{cl}\n$Help{mv}\n$Help{pl}\n$Help{ps}\n$Help{rm}\n$Help{st}\n$Help{sw}
$Help{res}\n$Help{rev}
EXIT STATUS
    0, on success
    1, on argument error
    2, when missing filename or similar
    3, when trying to run outside of a git repository
    4, on dependency error
  130, on user action

DEPENDENCIES
    git

VERSION
    $Version

AUTHOR(S)
    $Author
EOF
; exit(0);
}


my $Debug     = '';
my @Optional  = ('d', 'i', 'l', 's', 'st');
my @Requires  = ('a', 'b', 'c', 'm', 'cl', 'mv', 'rm', 'sw', 'res', 'rev');
my $TargetOpt = ''; my $TargetReq = '';


# Preliminary checks
# ------------------
# Dependencies:
`git -v 2>/dev/null` or SigHandler('DepErr', 'git');

# Help, Debug, Requires / Optional:
if (local $_ = $ARGV[0]) {
  if (/^(?:(-)?h|--help|-\?)$/) {
    do { Help(); exit(0) }          if not $ARGV[1];
    SigHandler('HelpErr', $ARGV[1]) if not $Help{$ARGV[1]};
    print "$Help{$ARGV[1]}"; exit(0);
  }

  do { $Debug = 'True'; shift; }  if /^D$/;
  SigHandler('DebugErr')          if $Debug and not $ARGV[0];

  foreach (@Requires) { do { $TargetReq = 'True'; last } if /^$ARGV[0]$/ };
  foreach (@Optional) { do { $TargetOpt = 'True'; last } if /^$ARGV[0]$/ };
}


# -----------------
# Option processing
# -----------------
my $Action; my $Opts; my @Targets; my $NoProc;
my %Disp = (); my %Prio = (); my %Rstr = (); my @Args;

my sub Default() {
  $Action = 'status';
  $Opts   = '-s';
}

my sub OptProc($\%\%\%\@) {
  my $Action  = shift; # action
  my $Opts    = '';    # internal Optstring
  my $rDisp   = shift; # dispatch table
  my $rPrio   = shift; # priority hash
  my $rRstr   = shift; # restrict hash
  my $rArgs   = shift; # arguments
  my %Disp = %$rDisp; my %Prio = %$rPrio;
  my %Rstr = %$rRstr; my @Args = @$rArgs;
  undef $rDisp; undef $rPrio; undef $rRstr; undef $rArgs;

  my sub DynProc($) {
    local $_ = shift;
    if ($Action eq 'clone' and $Disp{_1} eq '' and /^\d+$/) {
      return (1, '--depth '.$_) 
    }
    if ($Action eq 'commit' and $Disp{_1} eq '') {
      my $Msg1; my $Msg2;
      unshift(@Args, $_); s/"/\\"/g foreach @Args;
      join(' ', @Args) =~ /^(.*?)(?:\s+%%\s+(.*?))?$/;
      $1 and $Msg1 = "-m \"$1\"" or $Msg1 = '';
      $2 and $Msg2 = "-m \"$2\"" or $Msg2 = '';
      undef @Args;
      return (1, $Msg1.' '.$Msg2);
    }
    if ($Action eq 'diff' and $Disp{_1} eq '') {
      unshift(@Args, $_); my $Commits = join(' ', @Args); undef @Args;
      return(1, $Commits);
    }
    if ($Action eq 'init' and $Disp{_1} eq '-b master') {
      return (1, '-b '.$_);
    }
    return (1, '-'.$_) if $Action eq 'log' and $Disp{_1} eq '-4' and /^\d+$/;
    return undef;
  }

  my sub PrioSort(\%) {
    my $Hash = shift;
    $Prio{(%$Hash)[0]} = 0 if scalar %$Hash == 1 and scalar %Prio == 0;
    sort
    { $Prio{$a} = 9 if $a eq 'D';     $Prio{$b} = 9 if $b eq 'D';
      $Prio{$a} = 0 if not $Prio{$a}; $Prio{$b} = 0 if not $Prio{$b};
      return -1 * ($Prio{$a} <=> $Prio{$b});
    } keys %$Hash;
  }

  my sub RstrRemove($) {
    my $K = shift;
    if (local $_ = $Rstr{$K}) {
      my @Rstr = split('');
      delete $Disp{$_} foreach @Rstr;
    }
  }

  while (local $_ = shift @Args) {
    if ($Disp{$_}) { # Processes static options
      $Opts .= $Disp{$_}.' ';
      delete $Disp{$_};
      RstrRemove($_);
    }
    else { # Processes dynamic option
      my ($K, $V) = DynProc($_);
      $K and $Disp{'_'.$K} = $V or SigHandler('ArgErr', $_);
    }
  }

  foreach (PrioSort %Disp) {
    next if $Prio{$_} <= -1 or not $Disp{$_};
    RstrRemove($_);
    $Opts .= $Disp{$_}.' ';
  }
  return $Opts;
}

my sub TargetProc($$$) {
  my $Action    = shift;
  my $Opts      = shift;
  my $TargetReq = shift;
  my @Targets   = @ARGV; shift @Targets if @Targets and $Targets[0] eq '--';

  # Verify sufficient number of targets present:
  local $_ = $Action;
  undef $TargetReq if /^branch$/ and $Opts =~ /--list/;
  undef $TargetReq if /^commit$/ and $Opts =~ /--amend/;
  undef $TargetReq if /^merge$/  and $Opts =~ /--(abort|continue|quit)/;
  if ($TargetReq) {
    SigHandler('MvDErr')    if /^mv$/ and scalar @Targets == 1;
    if (not @Targets) {
      SigHandler('BranchErr') if /^branch|merge|switch$/;
      SigHandler('URLErr')    if /^clone$/;
      SigHandler('CommErr')   if /^revert$/;
      SigHandler('FileErr');
    }
  }

  # Edge-case handling:
  if (/^clone$/ and local $_ = $Targets[0]) {
    unless (m{^(?:\.)?/}) {
      my $Schema = 'https://'    if m{^(?!http(?:s)?://)};
      my $Host   = 'github.com'  if m{^%.*$};
      s/%/\//; $Targets[0] = $Schema.$Host.$_;
    }
  }
  elsif (/^rm$/ and $Opts =~ /(?<!--cached)-r(?!--cached)/) {
    print STDERR "+---------+\n| WARNING |\n+---------+";
    my $Confirm = '';
    until ($Confirm =~ /^(?:y|n|\n)$/i) {
      printf 'Confirm non-cached, recursive removal (y/N): ';
      $Confirm = <STDIN>;
    }
    SigHandler('SigInt') if $Confirm =~ /^(?:n)?\n$/i;
  }

  # Escape spaces:
  s/ /\\ /g foreach @Targets;
  return @Targets;
}


if (local $_ = shift) {
  if (/^a$/) {
    $Action = 'add';
    %Disp = (p => '--patch');
    %Prio = (p => -1);
  }
  elsif (/^b$/) {
    $Action = 'branch';
    %Disp = (c => '-c',   d => '-d',  l => '--list',  m => '-m');
    %Prio = (c => 1,      d => 1,     l => 2,         m => 1);
    %Rstr = (c => 'dlm',  d => 'clm', l => 'cdm',     m => 'cdl');
  }
  elsif (/^c$/) {
    $Action = 'commit';
    %Disp = (a => '--amend', _1 => '');
    %Prio = (a => -1);
  }
  elsif (/^d$/) {
    $Action = 'diff';
    %Disp = (c => '--cached', _1 => '');
    %Prio = (c => -1);
  }
  elsif (/^f$/) { $NoProc = 'True'; $Action = 'fetch'; }
  elsif (/^l$/) {
    $Action = 'log';
    %Disp = (
      D => '--abbrev-commit',  s => '--pretty=oneline', l => '--pretty=medium',
      n => '--name-only',     _1 => '-4'
    );
    %Prio = (s => 2,    l => 1,   n => -1,);
    %Rstr = (s => 'l',  l => 's');
  }
  elsif (/^i$/) {
    $Action = 'init';
    %Disp = (b => '--bare', _1 => '-b master');
    %Prio = (b => -1);
  }
  elsif (/^m$/) {
    $Action = 'merge';
    %Disp = (a => '--abort',  c => '--continue',  q => '--quit');
    %Prio = (a => -1,         c => -2,            q => -2);
    %Rstr = (a => 'cq',       c => 'aq',          q => 'ac');
  }
  elsif (/^s$/) {
    $Action = 'status';
    %Disp = (s => '-s', l => '--long',  c => '--ahead-behind');
    %Prio = (s => 2,    l => 1,         c => -1);
    %Rstr = (s => 'l',  l => 's');
  }
  elsif (/^cl$/) {
    $Action = 'clone';
    %Disp = (_1 => '');
  }
  elsif (/^mv$/) { $Action = 'mv'; }
  elsif (/^pl$/) {
    $Action = 'pull';
    %Disp = (n => '--no-rebase',  r => '--rebase');
    %Prio = (n => 2,              r => 1);
    %Rstr = (n => 'r',            r => 'n');
  }
  elsif (/^ps$/) { $NoProc = 'True'; $Action = 'push'; }
  elsif (/^rm$/) {
    $Action = 'rm';
    %Disp = (c => '--cached', n => ' ', r => '-r');
    %Prio = (c => 2,          n => 1,   r => -1);
    %Rstr = (c => 'n',        n => 'c');
  }
  elsif (/^st$/) {
    $Action = 'stash';
    %Disp = (
      c => 'clear', l => 'list', o => 'pop', u => 'push', s => 'show'
    );
    %Prio = (c => 1,      l => 2,      o => 1,      u => 1,      s => 1);
    %Rstr = (c => 'lous', l => 'cuos', o => 'clus', u => 'clos', s => 'clou');
  }
  elsif (/^sw$/) { $Action = 'switch'; }
  elsif (/^res$/) {
    $Action = 'restore';
    %Disp = (s => '--staged', n => ' ');
    %Prio = (s => 2,          n => 1);
    %Rstr = (s => 'n',        n => 's');
  }
  elsif (/^rev$/) {
    $Action = 'revert';
    %Disp = (e => '-e', n => '--no-edit');
    %Prio = (e => 2,    n =>  1);
    %Rstr = (e => 'n',  n => 'e');
  }
  elsif (/^--$/) {
    Default();
  } else { SigHandler('ArgErr', $_); }

  if (not /^--$/) { # Generate @Args
    push(@Args, shift) until not @ARGV or $ARGV[0] eq '--';
  }

  unless ($NoProc) {
    $Opts     = OptProc($Action, %Disp, %Prio, %Rstr, @Args);
    @Targets  = TargetProc($Action, $Opts, $TargetReq);
  } else { $Opts = ''; @Targets = (); }
}   else { Default(); }


# Exception handling
# ------------------
unless ($Debug) {
  if ($Action eq 'status' and $Opts =~ /--ahead-behind/) {
    `git status --ahead-behind` =~ /(Your branch is .*\.)/;
    print $1 if $1; exit(0);
  }
}

# Build command string
# --------------------
my $Command = "git $Action $Opts -- @Targets"; $Command =~ s/\s+/ /g;

# Repository check
# ----------------
unless ($Debug or $Action =~ /^clone|init$/) {
  `git rev-parse --is-inside-git-dir 2>/dev/null` or SigHandler('RepoErr');
}

# Debugging information / Git command execution
# ---------------------------------------------
if ($Debug) {
  $TargetReq or $TargetReq = 'False';
  $TargetOpt or $TargetOpt = 'False';
  print "- DEBUG MODE -\nAction: $Action\nOpts:   $Opts\n";
  print "TargetReq: $TargetReq\nTargetOpt: $TargetOpt\nTarget(s):";
  print "    $_" foreach @Targets;
  print "\nGit command to be run:\n    $Command";
} else { system("$Command"); }
