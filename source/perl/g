#!/usr/bin/perl
use warnings;
use strict;

# NOTE:
#
# TODO:
# add git-diff as 'd'
# add git-merge as 'm'
# add git-revert as 'r'
# add git-switch as 'sw'
# allow use of second '-m' for sub-messages

my $Author    = 'Nico Pareigis';
my ($Program) = $0 =~ m{^.*/(\w+)$};
my $Version   = '0.0.5';

sub Usage {
printf <<EOF
NAME
    $Program - shorthands for git commands

SYNOPSIS
    $Program [D] [OPTS [SUBOPTS]] [-- FILES|URL]

DESCRIPTION
    $Program aims to provide some useful shorthands for basic git operations. It
    doesn't aim to support all of git's features or functionality.
    Running $Program without any options runs 'git status -s' on either the en-
    tire repository, or on FILES, if any are specified.

OPTIONS
    D
      Run $Program in debug / dry-run mode. Print relevant information, but
      don't run the actual git command.

    [-]h
      Print this help information and exit.

    a -- FILES
      Run 'git add' on FILES.

    c ['commit msg' ['secondary commit msg']] -- FILES
      Run 'git commit' on FILES. Optionally takes one or two commit messages.
      The second commit message acts as if it were passed as a second '-m msg'
      to git.

      ---
      PROVIDING A SECONDARY COMMIT MESSAGE DOES NOT WORK YET!
      ---

    f
      Run 'git fetch' on the current repository.

    l [sl] [INT] [-- FILES]
      Run 'git log --abbrev-commit --no-decorate' on the current repository, or
      on FILES, if any are specified. 's' (as in 'short' (i.e. --pretty=oneline),
      default) and 'l' (as in 'long' (i.e. --pretty=medium) dictate the listing
      format.
      Optionally takes an integer to specify the number of commits to show (de-
      fault is 4).

    s [slc] [-- FILES]
      Run 'git status' on the current repository, or on FILES, if any are spe-
      cified. 's' (-s, default) and 'l' (--long) dictate the listing format. 'c'
      (as in 'compare') shows the branch's status compared to upstream.

    cl -- URL
      Clone the repository located at URL.

    pl [nr]
      Run 'git pull' on the current repository. 'n' (--no-rebase, default) and
      'r' (--rebase) dictate whether or not git should rebase already commited
      changes.

    ps
      Run 'git push' on the current repository.

    re -- FILES
      Run 'git restore --staged' on staged FILES.

    rm [cn] [r] -- FILES
      Run 'git rm' on FILES. 'c' (--cached, default) and 'n' (as in 'not cached')
      dictate whether or not git should remove files only from the index, or if
      they should be completely removed from the disk. 'r' (-r) allows recursive
      removal of entire directory structures (USE WITH CAUTION!).

EXIT STATUS
    0, on success
    1, on argument error
    2, when missing filename(s) or URL
    3, when trying to run outside of a git repository
    4, on dependency error

DEPENDENCIES
    git

VERSION
    $Version

AUTHOR(S)
    $Author
EOF
;
exit(0);
}

my sub Err {
  printf STDERR "Error: %s\n", $_[1];
  exit($_[0]) if $_[0] > 0;
}

my $Debug = '';
my $TargetRequired = '';
my sub SigHandler {
  Usage()                                     if $_[0] eq 'Usage';

  Err(1, 'Illegal argument - '.$_[1])         if $_[0] eq 'ArgErr';
  Err(2, 'No filename(s) / URL specified!')   if $_[0] eq 'FileErr';
  Err(3, 'Not running in a git repository!')  if $_[0] eq 'RepoErr';
  Err(4, 'Dependency not met - '.$_[1])       if $_[0] eq 'DepErr';

  $Debug          = 'True', shift @ARGV       if $_[0] eq 'DebugMode';
  $TargetRequired = 'True'                    if $_[0] eq 'TargetReq';
}


# Dependency-, help-, debug mode, and required target checks
system('command -v git 1>/dev/null 2>&1') == 0
  or SigHandler('DepErr', 'git');
if (defined $ARGV[0]) {
  SigHandler('Usage')     if $ARGV[0] =~ /^((-)?h|--help|-\?)$/;
  SigHandler('DebugMode') if $ARGV[0] eq 'D';
}
SigHandler('TargetReq') if defined $ARGV[0] and $ARGV[0] =~ /^[ac]|cl|re|rm$/;


# Argument processing
my $Action  = '';
my $Options = '';
my $Target  = '';

while (scalar @ARGV > 0) {
  if ($ARGV[0] =~ /^--$/) {
    shift; foreach (@ARGV) {
      $_ =~ s/ /\\ /;
      $Target = $Target.$_.' ';
    }

    $/ = ' '; chomp($Target);
    last;
  }

  elsif ($ARGV[0] =~ /^a$/) {
    $Action = 'add';
    shift;
  }

  elsif ($ARGV[0] =~ /^c$/) {
    # Err(12, 'Not properly implemented yet! Please refrain from using for the time being.');

    # /\w+\s+--(\s+\w+)+$/                        comm + file
    # /^\s*--(\s+\w+)+$/                          file
    # /^(\s*\w+)+$/                               comm
    # $String =~ /(\w+\s+)+\s+(--(?:\s+\w+)+)?$/; all

    # if ($String =~ /^(\s*\w+)+(?:\s+--\s+.*)?/) { # needs alternative -- file
    # if ($String =~ /^\s*((?:'|")(?:.*)+(?:'|"))*\s+(--\s+.*)?/) {

    $Action   = 'commit';
    shift;

    my $String  = join(' ', @ARGV);
    if ($String =~ /^(?:(.*)(?:\s+))?(--\s+.*)$/) {
      $Options = "-m '$1'" if $1;
      @ARGV = split(' ', "$2");
    }

    SigHandler('FileErr') if !$2;
  }

  elsif ($ARGV[0] =~ /^f$/) {
    $Action = 'fetch';
    last;
  }

  elsif ($ARGV[0] =~ /^l$/) {
    $Action       = 'log';
    $Options      = '--abbrev-commit --no-decorate --pretty=';
    my $Display   = 'oneline';
    my $Count     = ' -4';

    if (defined $ARGV[1]) {
      if ($ARGV[1] eq 's') {
        shift;
      }

      elsif ($ARGV[1] eq 'l') {
        $Display = 'medium';
        shift;
      }

      if (defined $ARGV[1] and $ARGV[1] =~ /^[1-9][0-9]*$/) {
        $Count = ' -'.$ARGV[1];
        shift;
      }
    }

    $Options = $Options.$Display.$Count;
    shift;
  }

  elsif ($ARGV[0] =~ /^s$/) {
    $Action   = 'status';
    $Options  = '-s';

    if (defined $ARGV[1]) {
      if ($ARGV[1] eq 's') {
        shift;
      }

      elsif ($ARGV[1] eq 'l') {
        $Options = '--long';
        shift;
      }

      elsif ($ARGV[1] eq 'c') {
        `git status --long --ahead-behind 2>/dev/null` =~ /(Your branch is .*\.)/;

        unless ($Debug) {
          printf $1."\n";
          exit(0);
        }
        shift;
      }
    }
    shift;
  }

  elsif ($ARGV[0] =~ /^cl$/) {
    $Action = 'clone';
    shift;
  }

  elsif ($ARGV[0] =~ /^pl$/) {
    $Action   = 'pull';
    $Options  = '--no-rebase';

    if (defined $ARGV[1]) {
      if ($ARGV[1] eq 'n') {
        shift;
      }

      elsif ($ARGV[1] eq 'r') {
        shift;
        $Options = '--rebase';
      }
    }
    shift;
  }

  elsif ($ARGV[0] =~ /^ps$/) {
    $Action = 'push';
    last;
  }

  elsif ($ARGV[0] =~ /^re$/) {
    $Action   = 'restore';
    $Options  = '--staged';
    shift;
  }

  elsif ($ARGV[0] =~ /^rm$/) {
    $Action   = 'remove';
    $Options  = '--cached';

    if (defined $ARGV[1]) {
      if ($ARGV[1] eq 'c') {
        shift;
      }

      elsif ($ARGV[1] eq 'n') {
        $Options = '';
        shift;
      }

      if (defined $ARGV[1] and $ARGV[1] eq 'r') {
        $Options = $Options.' -r';
        shift;
      }
    }
    shift;
  }

  SigHandler('ArgErr', $ARGV[0]) if defined $ARGV[0] and $ARGV[0] ne '--';
}


# Set default $Action if no arguments were passed
$Action = 'status', $Options = '-s' if !$Action;


# Throw error if $Action requires target but none was passed
# or unset $Target if $Action doesn't require target but one was passed
if ($TargetRequired and !$Target) {
  SigHandler('FileErr');
}
if (!$TargetRequired and $Target) {
  $Target = '' unless $Action =~ /^status|log$/;
}


# Print debugging information if running in debug / dry-run mode
if ($Debug) {
  printf "Debug mode output:\n\n";
  printf "Action:  $Action\nOptions: $Options\nTarget:  $Target\n";
  exit(0);
}


# Check if running in git repository (skip this when cloning)
unless ($Action eq 'clone') {
  system('git branch --show-current 1>/dev/null 2>&1') == 0
    or SigHandler('RepoErr');
}


# Git command execution
system("git $Action $Options -- $Target");
