#!/usr/bin/perl
use strict; use warnings; $\ = "\n";

# Feature:
#   * implement -u|--uuid
# Issue Tracker:
#   * current option processing allows 's' and '-long'

my $Author    = 'Nico Pareigis';
my ($Program) = $0 =~ m{/(.+)$};
my $Version   = '0.0.2';

use constant DISKBYID   => '/dev/disk/by-id/';
use constant PROCMOUNT  => '/proc/mounts';


my $C         = '';
my $Dev       = '';
my $Part      = 1;
my $Mtime     = 0;
my $Mnt       = 'f';
my $MntPoint  = '';
my $FMnt      = 'f';
my $UMnt      = 't';
my $UsbOnly   = 'f';
my $DbP    = 'db.kdbx';

my %Opts = (
  b => 'blockdev',  h => 'help', n => 'noumount',
  p => 'partition', u => 'uuid'
);
my %RequiresArg = (
  b => 'blockdev', p => 'partition', u => 'uuid'
);


my sub Clean {
  if ($Dev and (($Mnt eq 'f' and $UMnt eq 't') or $FMnt eq 't')) {
    `udisksctl unmount -b $Dev` or
      print STDERR $Program.': improper termination - '.$Dev.' still mounted!';
  }
}
my sub Err {
  print STDERR "$Program: $_[1]";
  Clean()     if $C eq 't';
  exit($_[0]) if $_[0] > 0;
}
my sub SigHandler { local $_ = shift;
  Err(  1, 'illegal argument - '.shift)           if /^ArgErr$/;
  Err(  1, 'not enough arguments for '.shift)     if /^NumErr$/;
  Err(  2, shift.' doesn\'t exist.')              if /^DevErr$/;
  Err(  2, 'udisks2 mount failure.')              if /^UMErr$/;
  Err(  2, 'udisks2 unmount failure.')            if /^UUErr$/;
  Err(  3, 'file ('.shift.') doesn\'t exist.')    if /^DbFErr$/;
  Err(  3, 'fatal keepass failure.')              if /^KeeErr$/;
  Err(  7, 'can\'t close dirhandle for '.shift)   if /^DCErr$/;
  Err(  7, 'can\'t open dirhandle for '.shift)    if /^DOErr$/;
  Err(  7, 'can\'t close filehandle for '.shift)  if /^FCErr$/;
  Err(  7, 'can\'t open filehandle for '.shift)   if /^FOErr$/;
  Err(  7, 'dependency not met - '.shift)         if /^DepErr$/; 
  Err(130, 'caught interrupt.')                   if /^SigInt$/;
} $SIG{INT} = sub { SigHandler('SigInt'); };

my sub Help {
print "NAME
    $Program - mount partition -> open keepass database -> unmount partition

SYNOPSIS
    $Program [OPTS] [-- PATH]

DESCRIPTION
    perl-keepass-mount ($Program) can be used to quickly and conveniently access
    a keepass *.kdbx database.
    The disk the database resides on will be automounted in userspace via
    udisks2 if it's not mounted already. If the disk was not mounted initially,
    it will automatically be unmounted after keepass exits (unless n-flag is
    passed).

    PATH may be used to specify a database path RELATIVE to the partition's
    mount point. If not used, the database is assumed to reside directly below
    the partition's mount point.

OPTIONS
    -b | --blockdev DEV
        Use DEV as the block device to mount, instead of the one that was most
        recently mounted. DEV is assumed to reside in /dev.
        (also see -u)

    -f | --force-unmount
        $Program usually doesn't unmount partitions that were already mounted
        when the script is run. With this option, $Program will always try to
        unmount the partition holding the database.
        (also see -n)

    -h | --help
        Print this help information and exit.

    -n | --no-unmount
        Don't unmount partition after keepass exits, even if not mounted
        initially.
        (also see -f)

    -o | --only-usb
        Only consider devices beginning with 'usb-' when auto-detecting device
        and partition.

    -p | --partition INT
        Use INT as the partition number the database resides on.

    -u | --uuid UUID (TO BE IMPLEMENTED)
        Use UUID as the partition's uuid.
        (also see -b)

EXIT STATUS
    0, on success
    1, on argument error
    2, on mount error
    3, on database|keepass error
    7, on miscellaneous error
  130, on keyboard interrupt

DEPENDENCIES
    keepass (any)
    udisks2 (tested with v.2.9.4-1)

VERSION
    $Version

AUTHOR
    $Author"; exit(0);
}


# Dependency checks:
my @Deps = ('keepass', 'udisksctl'); my @MDeps;
foreach my $Dep (@Deps) {
  my $Installed;
  foreach my $Dir (split(':', $ENV{PATH})) {
    $Dir .= '/' if $Dir !~ /\/$/;
    -f $Dir.$Dep and do {$Installed = 1; last};
  }
  push(@MDeps, $Dep) unless $Installed;
}
SigHandler('DepErr', join(', ', @MDeps)) if @MDeps;


# Switch parsing:
while (local $_ = shift) {
  my $X = $_; s/-//g;
  unless($X eq '--') {
    # SigHandler('ArgErr', $X) if not $_ ~~ [keys %Opts, values %Opts];
    ($Opts{$_} or grep($_ eq $X, values %Opts)) or SigHandler('ArgErr', $X);
    SigHandler('NumErr', $X) if $RequiresArg{$_} and not @ARGV;
  }

  if (/^h|help$/) {
    Help();
  }
  elsif (/^b|blockdev$/) {
    local $_ = shift;
    SigHandler('ArgErr', $_) if not /^[a-z\d]+$/;
    $Dev = $_;
  }
  elsif (/^f|forceunmount$/) {
    $FMnt = 't';
  }
  elsif (/^n|nounmount$/) {
    $UMnt = 'f';
  }
  elsif (/^o|onlyusb$/) {
    $UsbOnly = 't';
  }
  elsif (/^p|partition$/) {
    local $_ = shift;
    SigHandler('ArgErr', $_) if not /^\d+$/;
    $Part = $_;
  }
  elsif (/^u|uuid$/) {
    local $_ = shift;
    SigHandler('ArgErr', $_) if not /^\d+$/;
  }
  elsif (/^$/) {
    $DbP = join(' ', @ARGV) if @ARGV; last;
  }
}


unless ($Dev) {
  # Get newest connected disk and relevant partition:
  opendir(DH, DISKBYID) or SigHandler('DOErr', DISKBYID);
  local @_ = readdir DH; splice(@_, 0, 2);
  closedir(DH) or die SigHandler('DCErr', DISKBYID);

  foreach (@_) {
    next if /-part\d+$/;
    next if $UsbOnly eq 't' and not /^usb-/;
    if ($Mtime < (lstat DISKBYID.$_)[9]) {
      (readlink DISKBYID.$_) =~ /([a-z0-9]*)$/;
      $Dev    = '/dev/'.$1.$Part;
      $Mtime  = (stat _)[9];
      # Speed up processing with large number of devices:
      last if time - $Mtime < 10;
    }
  }
} else {
  $Dev = '/dev/'.$Dev.$Part;
}
SigHandler('DevErr', $Dev) if not -b $Dev;


# Check mountpoint:
open(FH, '<', PROCMOUNT) or SigHandler('FOErr', PROCMOUNT);
while (<FH>) {
  local @_ = split(' ');
  if ($_[0] eq $Dev) {
    $Mnt      = 't';
    $MntPoint = $_[1];
  }
}
close(FH) or SigHandler('FCErr', PROCMOUNT);


# Mount partition if necessary:
if ($Mnt eq 't') {
  print $Dev.' already mounted ('.$MntPoint.') - opening database.';
  $UMnt = 'f';
}
else {
  `udisksctl mount -b $Dev` =~ /^Mounted $Dev at (.*)$/ or SigHandler('UMErr');
  $MntPoint = $1;
  $C = 't';
}

# Open database:
my $DbF = $DbP;
$DbF    = $MntPoint.'/'.$DbF if $DbP !~ /^(?:\.)?\//;
-e $DbF or SigHandler('DbFErr', $DbF);
`keepass $DbF`;
$? == 0 or SigHandler('KeeErr');

# Unmount partition:
`udisksctl unmount -b $Dev` or SigHandler('UUErr') if $FMnt eq 't' or $UMnt eq 't';
