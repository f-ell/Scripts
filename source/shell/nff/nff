#!/bin/sh

Authors='Nico Pareigis'
Program=${0##*/}
Version=0.3.9

Usage() {
printf "NAME
    $Program - (Neo)Vim-Fuzzy-Finder - find file in filesystem and open it with
    Vi, Vim, or NeoVim

SYNOPSIS
    $Program [OPTS] [DIR] [EXP]

DESCRIPTION
    Recursively search through directories and select one or more files. The
    selected file(s) will be opened in either Vi, Vim, or NeoVim (ascending
    priority). Optionally, specify a search directory and/or expression to be
    matched.

    DIR specifies the directory to run $Program in; the default is \$PWD.

    'EXP' allows the user to specify multiple search expressions/filenames as a
    space-separated list. If $Program finds a file matching the expression, the
    file is added to a list that will be opened in the editor. If a match only
    has a single candidate, this is done automatically. Otherwise fzf, fzy, or
    zf (descending priority) is used to interactively select a match.

    When using fzf for fuzzy finding, part of the user's \$FZF_DEFAULT_OPTS may
    temporarily be overwritten.

OPTIONS
    -d, --depth INT
      Takes a positive, non-zero integer and uses it as the search depth. A high
      search depth will include more / better results, but may significantly
      increase script runtime.
      Default search depth is 10.

    -E, --editor
      Uses \$EDITOR instead of the internally calculated editor.

    -f, --zf
      Use zf for fuzzy finding.

    -g, --no-git-ignore
      $Program excludes any file / directory matching '.git*' that it encounters
      during the search. Using this option prevents those matches from being
      removed from search results. Can be used in combination with patterns,
      specified either in a separate file, or on the command line (see -e and -p
      respectively), to only show specific git-related results.

    -i, --ignore FILE
      Use FILE containing patterns to ignore files and directories in search
      results. Patterns support globbing characters and should be separated by
      newlines. Avoid prefixing patterns with '**/', as that's how they are
      being matched internally and prefixing them as such would prevent
      exclusion of all files / directories that are first-hand children of DIR.
      Furthermore, patterns should consist of the shortest, unambiguous part of
      the filenames / directories one wishes to exclude.

      By default $Program tries to source a file named 'exclude.nff', located in
      the script's directory, to filter unwanted search results. If one wants to
      not exclude any results, ensure a file with aforementioned name does not
      exist in the script's directory, or pass '-' as FILE to this option.

      EXAMPLE:
      Assume the contents of '/path/to/first/directory/' are to be discarded but
      contents of '/path/to/second/directory/' are to be kept as search results.
      To achieve this, put 'first/directory' in the pattern file. Alternatively,
      if anything matching 'directory' is to be discarded just put 'directory'
      in the pattern file.

      This repository ships a very minimal 'exclude.nff' that can be built upon.

    -l
      Include symlinked files in search results (traverses symlinks).

    -o, --fuzzy-opts STRING
      Overwrite the builtin fuzzy-finder options with STRING. STRING is passed
      to the finder verbatim, with no additional validity checks. Parsing will
      break in case STRING contains characters that mess with word-splitting,
      namely spaces.

      EXAMPLE:
      To use the environment's \$FZF_DEFAULT_OPTS with fzf, call $Program as:
      '$Program [-z] -o \"\$FZF_DEFUALT_OPTS\"'

    -p, --pattern PATTERN
      Use PATTERN to exclude files / directories from being matched. Can be used
      more than once.
      See -e for an example on proper PATTERN formatting.

    -v, --version
      Output version information and exit.

    -y, --fzy
      Use fzy for fuzzy finding.

    -z, --fzf
      Use fzf for fuzzy finding.

KNOWN BUGS
    Due to shell limitations, expressions / filenames containing spaces are not
    handled properly and should be avoided.

    Specifying an option right after an option that expects an argument assumes
    that the second option is the argument to the first; the missing argument is
    not detected.

EXIT STATUS
      0, on success.
      1, on argument error.
      2, when no file is found. Most likely caused by a poor EXP and/or a
         shallow search depth.
      7, on dependency error.
    130, on keyboard interrupt.

DEPENDENCIES
    Coreutils:
    wc                (any)

    Other:
    fd                (v8.3.2+)
    fzf | fzy | zf    (v0.30.0+ | v1.0+ | v0.5+)
    vi  | vim | nvim  (any, optional with -E)

VERSION
    $Version

AUTHOR(S)
    $Authors\n"
}


unset VerWrn FnfWrn DirErr DptErr IgnErr NoAErr NoFErr DepErr SigInt
SigHandler() {
  [ "$VerWrn" = 1 ] && Err   0 "'$1' version ($2) is outdated and may not function appropriately"
  [ "$FnfWrn" = 1 ] && Err   0 "'$1' not found - skipping"
  [ "$ArgErr" = 1 ] && Err   1 "illegal argument - '$1'"
  [ "$DirErr" = 1 ] && Err   1 "directory '$1' does not exist"
  [ "$DptErr" = 1 ] && Err   1 'depth has to be a positive, non-zero integer'
  [ "$IgnErr" = 1 ] && Err   1 "file '$1' doesn't exist, isn't a valid file, or doesn't have read permissions"
  [ "$NoAErr" = 1 ] && Err   1 "missing argument for '$1'"
  [ "$NoFErr" = 1 ] && Err   2 'nothing to edit'
  [ "$DepErr" = 1 ] && Err   7 "dependency not met - $1"
  [ "$SigInt" = 1 ] && Err 130 'keyboard interrupt'
}


### Helper functions
Err() {
  printf '%s: %s\n' "$Program" "$2" 1>&2
  [ $1 -gt 0 ] && exit $1
}

VerifyArg() {
  [ -z "$2" -o "$2" = -- ] && NoAErr=1 SigHandler $1
}

DepAllOf() { # all of $@ are present
  for Dep in "$@"; do
    if ! command -v $Dep 1>/dev/null; then
      MissingDepCount=$((MissingDepCount+1))
      MissingDeps="$MissingDeps, $Dep"
    fi
  done
}
DepAnyOf() { # any of $@ is present
  for Dep in "$@"; do
    if command -v $Dep 1>/dev/null; then
      Return=$Dep
      return 0
    fi
  done
  MissingDepCount=$((MissingDepCount+1))
}

GetEditor() { # determine editor
  DepAnyOf nvim vim vi
  [ -z $Return ] && MissingDeps="$MissingDeps, vi | (n)vim" \
    || Editor=$Return
  unset Return
}
GetFuzzy() {  # determine fuzzy finder
  DepAnyOf fzf fzy zf
  [ -z $Return ] && MissingDeps="$MissingDeps, fzf | fzy | zf" \
    || Fuzzy=$Return
  unset Return
}

CheckSemanticVersion() {
  local Dep CurVer MinVer Major Minor Patch
  Dep=$1; CurVer=$2; MinVer=$3
  Major=${CurVer%%.*}
  Minor=${CurVer#*.}; Minor=${Minor%.*}
  Patch=${CurVer##*.}
  [ $Major$Minor$Patch -lt $MinVer ] && VerWrn=1 SigHandler $Dep $CurVer
}
CheckMajorMinorVersion() {
  local Dep CurVer MinVer
  Dep=$1; CurVer=$2; MinVer=$3
  Major=${CurVer%.*}
  Minor=${CurVer#*.}
  [ $Major$Minor -lt $MinVer ] && VerWrn=1 SigHandler $Dep $CurVer
}

FdVC() { # fd version check
  local Ver=`fd --version`
  CheckSemanticVersion 'fd' ${Ver#fd } 832
}
FzfVC() { # fzf version check
  local Ver=`fzf --version`
  CheckSemanticVersion 'fzf' ${Ver% *} 0300
}
FzyVC() { # fzy version check
  local Ver=`fzy --version`; Ver=${Ver#fzy }
  CheckMajorMinorVersion 'fzy' ${Ver% Â©*} 10
}
ZfVC() {  # zf version check
  local Ver Compat
  Ver=`zf --version`; Ver=${Ver#zf }; Ver=${Ver%% *}

  # compatibility with zf versions between 0.1.0 and 0.6.0
  Compat=${Ver#*.}; Compat=${Compat%.*}
  [ $Compat -gt 0 -a $Compat -le 5 ] \
    && CheckMajorMinorVersion 'zf' $Ver 05 || CheckSemanticVersion 'zf' $Ver 060
}

### Argument processing
Depth=10
Dir="$PWD"
ExcludePattern=''
Exp='. / '
ExpList=''
GitIgnore='**/.git*,'
IgnoreFile="${0%/*}/exclude.nff"
Ignore=''
Link=''

Editor=''
Fuzzy=''
FuzzyOpts=''
FzfOpts='-i -e --tiebreak=begin --reverse --prompt= --height=10 --no-color --no-info'
FzyOpts='--lines=10 --prompt='
ZfOpts='--lines 10'

while [ -n "$1" ]; do
  case "$1" in
    --)
      shift
      for Exp in "$@"; do
        [ "$ExpList" = "${ExpList%"$Exp"*}" ] && ExpList="$ExpList$Exp / "
      done
      break;;

    -h|--help)
      Usage; exit 0;;

    -d|--depth)
      VerifyArg $1 $2
      if [ $2 -eq $2 ] 2>/dev/null && [ $2 -gt 0 ]; then
        Depth=$2
      else
        DptErr=1 SigHandler
      fi
      shift 2;;

    -E|--editor)
      Editor="$EDITOR"
      shift;;

    -i|--ignore)
      VerifyArg $1 $2
      if [ "$2" = - ]; then
        unset IgnoreFile
        Ignore='--no-ignore'
      else
        [ ! -f "$2" -o ! -r "$2" ] && IgnErr=1 SigHandler "$2"
        IgnoreFile="$2"
      fi
      shift 2;;

    -f|--zf)
      Fuzzy=zf
      shift;;

    -g|--no-git-ignore)
      unset GitIgnore
      shift;;

    -l)
      Link=L
      shift;;

    -o|--fuzzy-opts)
      VerifyArg $1 $2
      FuzzyOpts="$2"
      shift 2;;

    -p|--pattern)
      VerifyArg $1 $2
      Pattern=${2%/}
      ExcludePattern="$ExcludePattern**/${Pattern#*/},"
      unset Pattern
      shift 2;;

    -v|--version)
      printf "$Program $Version $Authors\n";
      exit 0;;

    -y|--fzy)
      Fuzzy=fzy
      shift;;

    -z|--fzf)
      Fuzzy=fzf
      shift;;

    -*)
      Err 1 "invalid argument - '$1'.";;

    *)
      for Exp in "$@"; do
        # explicit split, argument invalid
        [ $Exp = '--' ] && ArgErr=1 SigHandler "$1"
      done

      [ "$1" != "${1%/}" -a ! -d "$1" ] && DirErr=1 SigHandler "$1"
      if [ -d "$1" ]; then
        Dir="$1"
        shift
      fi

      for Exp in "$@"; do
        [ "$ExpList" = "${ExpList%"$Exp"*}" ] && ExpList="$ExpList$Exp / "
      done
      break;;
  esac
done


### Dependency checks
MissingDepCount=0; MissingDeps='';
DepAllOf wc fd

# set editor and fuzzy finder if not implied by arguments
[ -z $Editor ]  && GetEditor
[ -z $Fuzzy ]   && GetFuzzy

[ $MissingDepCount -gt 0 ] && DepErr=1 SigHandler "${MissingDeps#, }"
unset Dep MissingDeps MissingDepCount


### Version checks
FdVC

if [ $Fuzzy = fzf ]; then
  FzfVC; FuzzyOpts="${FuzzyOpts:-$FzfOpts}"
elif [ $Fuzzy = fzy ]; then
  FzyVC; FuzzyOpts="${FuzzyOpts:-$FzyOpts}"
else [ $Fuzzy = zf ]
  ZfVC; FuzzyOpts="${FuzzyOpts:-$ZfOpts}"
fi


### Execution
# Construct $ExcludeList
if [ -n "$GitIgnore" -o -n "$ExcludePattern" -o -n "$IgnoreFile" ]; then
  ExcludeList='-E {'

  [ -n "$GitIgnore" ]       && ExcludeList="$ExcludeList$GitIgnore"
  [ -n "$ExcludePattern" ]  && ExcludeList="$ExcludeList$ExcludePattern"

  if [ -n "$IgnoreFile" ]; then
    while IFS='' read -r File; do
      File=${File%/}
      ExcludeList="$ExcludeList**/${File#*/},"
    done < "$IgnoreFile"
  fi

  ExcludeList="$ExcludeList}"
  unset ExcludePattern IgnoreFile
fi


# Construct $Files string
Files=''
FdCmd="fd $ExcludeList -tf -H$Link $Ignore -d$Depth -p"

[ -z "$ExpList" ] && ExpList="$Exp"
while [ -n "$ExpList" ]; do
  unset Match
  Count=`$FdCmd --max-results 2 -- "${ExpList%% / *}" "$Dir" | wc -l`

  # Emulate fzf's '-1' behaviour for other finders
  if [ $Count -eq 1 ]; then
    Match=`$FdCmd -- "${ExpList%% / *}" "$Dir"`
  elif [ $Count -gt 1 ]; then
    Match=`$FdCmd -- "${ExpList%% / *}" "$Dir" | $Fuzzy $FuzzyOpts`
    X=$?
    if [ $X -ne 0 ]; then
      [ $Fuzzy = fzf -a $X -eq 130 ]  && SigInt=1 SigHandler
      [ $X -eq 1 ]                    && SigInt=1 SigHandler
      Err 130 'uncaught fuzzy finder error.'
    fi
    unset X
  fi

  [ -n "$Match" ] && Files="$Files$Match " \
    || FnfWrn=1 SigHandler ${ExpList%% / *}

  [ "$ExpList" = "$Exp" ] && break

  ExpList="${ExpList#* / }"
done; Files="${Files% }"


# Open editor
[ -n "$Files" ] && $Editor $Files || NoFErr=1 SigHandler
