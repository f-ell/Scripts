#!/bin/sh

# TODO
# move '-1' implementation into encapsulated function
# -> no need to constantly re-set $OneFile

# Add $ExcludeFile as --ignore-file and update usage


# Deprecated (save if issues arise):
# FZF_DEFAULT_OPTS='-i --tiebreak=begin --reverse --prompt="" --height=20%
#   --no-color --no-info'

Authors='Nico Pareigis'
Program=${0##*/}
Version=0.3.0

Usage() {
printf "
NAME
    $Program - (Neo)Vim-Fuzzy-Finder - find file in filesystem and open it with
    Vi, Vim, or NeoVim

SYNOPSIS
    $Program [OPTS] [DIR] [-- EXP]

DESCRIPTION
    Recursively search through directories and select one or more files. The sel-
    ected file(s) will be opened in either Vi, Vim, or NeoVim. Should more than
    one of the aforementioned programs be installed, %s will prioritize them in
    reverse order. Optionally, specify a search directory and / or expression to
    be matched.


    DIR specifies the directory to run %s in; the default is \$HOME.

    '-- EXP' allows the user to specify multiple search expressions / filenames
    as a space-separated list. If %s finds a file matching the expression that
    file is added to a list; each file in the list will later be opened in its
    own buffer. If a match only has a single candidate, this is done automatica-
    lly. Otherwise, fzf or fzy is used to interactively select a candidate.

    When using fzf as the fuzzy finder, part of the user's \$FZF_DEFAULT_OPTS may
    temporarily be overwritten.


    IMPORTANT NOTE:
    Due to shell limitations, expressions / filenames containing spaces are
    currently unsupported and should not be used!

OPTIONS
    -d, --depth INT
      Takes a positive, non-zero Integer and uses it as the search depth. Using
      a high search depth has the advantage of showing better search results in
      deeply nested directory structures, but comes at the cost of a greater de-
      lay between issuing the command and opening the desired file(s).
      Default search depth is 10.

    -e, --exclude FILE
      Use FILE containing patterns to exclude files and directories from search
      results. Patterns support globbing characters and should be separated by
      newlines. Avoid prefixing patterns with '**/', as that's how they are
      being matched internally and prefixing them as such would prevent exclu-
      sion of all files / directories that are first-hand children of DIR.
      Furthermore, patterns should consist of the shortest, unambiguous part of
      the filenames / directories one wishes to exclude.

      By default %s tries to source a file called 'exclude.nff', located in the
      script's directory, to filter unwanted search results. If one wants to not
      exclude any results, ensure a file with aforementioned name does not exist
      in the script's directory, or pass '-' as FILE to this option.

      EXAMPLE:
      Assume the contents of '/path/to/first/directory/' are to be discarded but
      contents of '/path/to/second/directory/' are to be kept as search results.
      To achieve this, put 'first/directory' in the pattern file. Alternatively,
      if anything matching 'directory' is to be discarded just put 'directory'
      in the pattern file.

      The default 'exclude.nff' in this repository should give a good idea of
      how the file is structured, as well as provide a sane default setup that
      can easily be expanded upon.

    -g, --no-git-ignore
      %s excludes any file / directory matching '.git*' that it encounters du-
      ring the search. Using this option prevents those matches from being re-
      moved from search results.
      Can be used in combination with patterns, specified either in a separate
      file, or on the command line (see -e and -p respectively), to only show
      specific git-related results.

    -l
      Include symlinked files in search results (traverses symlinks).

    -p, --pattern PATTERN
      Use PATTERN to exclude files / directories from being matched. Can be used
      more than once.
      See -e for an example on proper PATTERN formatting.

    -y, --fzy
      Force fzy as the fuzzy finder. Without this, %s will default to using fzf,
      if both fzf and fzy are installed on the system.
      Note: when using this option no extra dependency or version checks are per-
      formed for fzy.

EXIT STATUS
      0, on success.
      1, on option error.
      2, when no file is found. Most likely caused by a poor EXP, accompanied by
         a shallow search depth.
      3, on dependency error.
    130, on keyboard interrupt.

DEPENDENCIES
    fd            (tested with v8.3.2)
    fzf | fzy     (tested with v0.30.0 | v1.0)
    vi  | (n)vim  (any)

VERSION
    $Version

AUTHOR(S)
    $Authors
" "$Program" "$Program" "$Program" "$Program" "$Program" "$Program"
}


Warn() {
  printf 'Warning: %s\n' "$1" 1>&2
}
Err() {
  printf 'Error: %s\n' "$2" 1>&2
  [ $1 -gt 0 ] && exit $1
}


unset Interrupt DependencyError VersionWarning DepthError DirError \
  ExcludeFileError FileNotFoundWarning
SigHandler() {
  [ "$Interrupt" = True ] && Err 130 "Keyboard Interrupt."

  [ "$DependencyError"  = True ] && Err 3 "Dependency not met - $1."
  [ "$VersionWarning"   = True ] \
    && Warn "'$1' version ($2) is not verified to work."

  [ "$DepthError"           = True ] \
    && Err 1 "Depth has to be a positive, non-zero integer."
  [ "$DirError"             = True ] \
    && Err 1 "Directory does not exist '$1'."
  [ "$ExcludeFileError"     = True ] \
    && Err 1 "Pattern File '$1' doesn't exist, isn't a file, or doesn't have read permissions."
  [ "$FileNotFoundWarning"  = True ] \
    && Warn "File not found '$1' - skipping."

  [ "$NoFile" = True ] && Err 2 'No file to open.'
}


# Checks if all dependencies in $@ are present on the system
DepAllOf() {
  for Dep in "$@"; do
    if ! command -v $Dep 1>/dev/null; then
      MissingDepCount=$((MissingDepCount+1))
      MissingDeps="$MissingDeps, $Dep"
    fi
  done
}

# Checks if at least one dependency in $@ is present on the system
DepAnyOf() {
  for Dep in "$@"; do
    if command -v $Dep 1>/dev/null; then
      Use=$Dep
      return 0
    fi
  done
  MissingDepCount=$((MissingDepCount+1))
}


# Runs checks for required dependencies
MissingDepCount=0; MissingDeps=''; Editor=''; Finder=''

DepAllOf fd

DepAnyOf nvim vim vi
[ -z "$Use" ] && MissingDeps="$MissingDeps, vi | (n)vim" || Editor=$Use

DepAnyOf fzf fzy
[ -z "$Use" ] && MissingDeps="$MissingDeps, fzf | fzy" || Finder=$Use

[ $MissingDepCount -gt 0 ] \
  && DependencyError=True SigHandler "${MissingDeps#, }"
unset Dep Use MissingDeps MissingDepCount


# Runs version checks for all dependencies
# Version check for fd
  FdCleanV=`fd --version`; FdCleanV=${FdCleanV#fd }

  Sup=${FdCleanV#?.}; Sup=${Sup%.?}
  FdV=${FdCleanV%%.*}; FdV=$FdV$Sup; FdV=$FdV${FdCleanV##*.}

  [ $FdV -lt 832 ]   && VersionWarning=True SigHandler fd $FdCleanV

# Version check for fuzzy finder
  if [ "$Finder" = fzf ]; then
    FzfCleanV=`fzf --version`; FzfCleanV=${FzfCleanV% *}
    Sup=${FzfCleanV#?.}; Sup=${Sup%.?}
    FzfV=${FzfCleanV%%.*}; FzfV=$FzfV$Sup
      FzfV=$FzfV${FzfCleanV##*.}

    [ $FzfV -lt 0300 ] && VersionWarning=True SigHandler fzf $FzfCleanV
  else
    FzyCleanV=`fzy --version`; FzyCleanV=${FzyCleanV#fzy }
      FzyCleanV=${FzyCleanV% Â©*}
    Sup=${FzyCleanV#?.}
    FzyV=${FzyCleanV%.?}$Sup

    [ $FzyV -lt 10 ] && VersionWarning=True SigHandler fzy $FzyCleanV
  fi

unset FdCleanV FzfCleanV FzyCleanV FdV FzfV FzyV Sup


# Argument processing
FzfOpts='-i -e --tiebreak=begin --reverse --prompt= --height=10 --no-color
  --no-info'
FzyOpts='--lines=10 --prompt='
Depth=10
Dir="$HOME"
ExcludeFile="${0%/*}/exclude.nff"
ExcludePattern=''
Exp='. / '
ExpList=''
GitIgnore='**/.git*,'
Link=''

while [ -n "$1" ]; do
  case "$1" in
    --)
      shift
      for Exp in "$@"; do
        [ "$ExpList" = "${ExpList%"$Exp"*}" ] && ExpList="$ExpList$Exp / "
      done
      break;;

    -h|--help)
      Usage; exit 0;;

    -d|--depth)
      if [ $2 -eq $2 ] 2>/dev/null && [ $2 -gt 0 ]; then
        Depth=$2
      else
        DepthError=True SigHandler
      fi
      shift 2;;

    -e|--exclude)
      if [ "$2" = - ]; then
        unset ExcludeFile
      else
        if [ ! -f "$2" ] || [ ! -r "$2" ]; then
          ExcludeFileError=True SigHandler "$2"
        fi
        ExcludeFile="$2"
      fi
      shift 2;;

    -g|--no-git-ignore)
      unset GitIgnore
      shift;;

    -l)
      Link=L
      shift;;

    -p|--pattern)
      Pattern=${2%/}
      ExcludePattern="$ExcludePattern**/${Pattern#*/},"
      unset Pattern
      shift 2;;

    -y|--fzy)
      Finder=fzy
      shift;;

    -*)
      Err 1 "Invalid option '$1'";;

    *)
      [ ! -d "$1" ] && DirError=True SigHandler "$1"
      Dir="$1"
      shift;;
  esac
done


# Construct $ExcludeList including all files to ignore when searching
if [ -n "$GitIgnore" ] || [ -n "$ExcludePattern" ] || [ -n "$ExcludeFile" ]; then
  ExcludeList='-E {'

  [ -n "$GitIgnore" ]       && ExcludeList="$ExcludeList$GitIgnore"
  [ -n "$ExcludePattern" ]  && ExcludeList="$ExcludeList$ExcludePattern"

  if [ -n "$ExcludeFile" ]; then
    while IFS='' read -r File; do
      File=${File%/}
      ExcludeList="$ExcludeList**/${File#*/},"
    done < "$ExcludeFile"
  fi

  ExcludeList="$ExcludeList}"
  unset ExcludePattern ExcludeFile
fi


if [ "$Finder" = fzf ]; then
  FinderOpts="$FzfOpts"
else
  FinderOpts="$FzyOpts"
fi
unset FzfOpts FzyOpts


# Construct $Files string to be opened
OneFile=True
Files=''
FdCmd="fd $ExcludeList -tf -H$Link -d$Depth"

[ -z "$ExpList" ] && ExpList="$Exp"
while [ -n "$ExpList" ]; do
  # Emulate fzf's '-1' behaviour for fzy
  [ `$FdCmd --max-results 2 -- "${ExpList%% / *}" "$Dir" | wc -l` -gt 1 ] \
    && OneFile=False || OneFile=True

  if [ "$OneFile" = False ]; then
    Match=`$FdCmd -- "${ExpList%% / *}" "$Dir" | $Finder $FinderOpts`
  else
    Match=`$FdCmd -- "${ExpList%% / *}" "$Dir"`
  fi

  # LEGACY:
  # Match="`fd $ExcludeList -tf -H$Link -d$Depth -- "${ExpList%% / *}" "$Dir" \
  #   | fzf -e -0 -1`"
  #   # | $Finder $FinderOpts`"

  Exit=$?
  if [ "$Finder" = fzf ]; then
    [ $Exit -eq 130 ] && Interrupt=True SigHandler
  else
    [ $Exit -eq 1 ]   && Interrupt=True SigHandler
  fi
  unset Exit

  [ -n "$Match" ] && Files="$Files$Match " \
    || FileNotFoundWarning=True SigHandler ${ExpList%% / *}

  [ "$ExpList" = "$Exp" ] && break

  ExpList="${ExpList#* / }"
done; Files="${Files% }"


# Open files in $Editor
[ -n "$Files" ] && $Editor $Files || NoFile=True SigHandler
