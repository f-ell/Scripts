#!/bin/sh

AUTHOR='Nico Pareigis'
PROGRAM=${0##*/}
VERSION=0.4.0

usage() {
printf "NAME
    $PROGRAM - (Neo)Vim-Fuzzy-Finder - find file in filesystem and open it with
    Vi, Vim, or NeoVim

SYNOPSIS
    $PROGRAM [OPTS] [DIR] [EXP]

DESCRIPTION
    Recursively search through directories and select one or more files. The
    selected file(s) will be opened in either Vi, Vim, or NeoVim (ascending
    priority). Optionally, specify a search directory and/or expression to be
    matched.

    DIR specifies the directory to run $PROGRAM in; the default is \$PWD.

    'EXP' allows the user to specify multiple search expressions/filenames as a
    space-separated list. If $PROGRAM finds a file matching the expression, the
    file is added to a list that will be opened in the editor. If a match only
    has a single candidate, this is done automatically. Otherwise fzf, fzy, or
    zf (descending priority) is used to interactively select a match.

    When using fzf for fuzzy finding, part of the user's \$FZF_DEFAULT_OPTS may
    temporarily be overwritten.

OPTIONS
    -d, --depth INT
      Takes a positive, non-zero integer and uses it as the search depth. A high
      search depth will include more / better results, but may significantly
      increase script runtime.
      Default search depth is 10.

    -E, --editor
      Uses \$EDITOR instead of the internally calculated editor.

    -f, --zf
      Use zf for fuzzy finding.

    -g, --no-git-ignore
      $PROGRAM excludes any file / directory matching '.git*' that it encounters
      during the search. Using this option prevents those matches from being
      removed from search results. Can be used in combination with patterns,
      specified either in a separate file, or on the command line (see -e and -p
      respectively), to only show specific git-related results.

    -i, --ignore FILE
      Use FILE containing patterns to ignore files and directories in search
      results. Patterns support globbing characters and should be separated by
      newlines. Avoid prefixing patterns with '**/', as that's how they are
      being matched internally and prefixing them as such would prevent
      exclusion of all files / directories that are first-hand children of DIR.
      Furthermore, patterns should consist of the shortest, unambiguous part of
      the filenames / directories one wishes to exclude.

      By default $PROGRAM tries to source a file named 'exclude.nff', located in
      the script's directory, to filter unwanted search results. If one wants to
      not exclude any results, ensure a file with aforementioned name does not
      exist in the script's directory, or pass '-' as FILE to this option.

      EXAMPLE:
      Assume the contents of '/path/to/first/directory/' are to be discarded but
      contents of '/path/to/second/directory/' are to be kept as search results.
      To achieve this, put 'first/directory' in the pattern file. Alternatively,
      if anything matching 'directory' is to be discarded just put 'directory'
      in the pattern file.

      This repository ships a very minimal 'exclude.nff' that can be built upon.

    -l
      Traverse symlinks.

    -o, --fuzzy-opts STRING
      Overwrite the builtin fuzzy-finder options with STRING. STRING is passed
      to the finder verbatim, with no additional validity checks. Parsing will
      break in case STRING contains characters that mess with word-splitting,
      namely spaces.

      EXAMPLE:
      To use the environment's \$FZF_DEFAULT_OPTS with fzf, call $PROGRAM as:
      '$PROGRAM [-z] -o \"\$FZF_DEFUALT_OPTS\"'

    -p, --pattern PATTERN
      Use PATTERN to exclude files / directories from being matched. Can be used
      more than once.
      See -e for an example on proper PATTERN formatting.

    -v, --version
      Output version information and exit.

    -y, --fzy
      Use fzy for fuzzy finding.

    -z, --fzf
      Use fzf for fuzzy finding.

KNOWN BUGS
    Due to shell limitations, expressions / filenames containing spaces are not
    handled properly and should be avoided.

    Specifying an option right after an option that expects an argument assumes
    that the second option is the argument to the first; the missing argument is
    not detected.

EXIT STATUS
      0, on success.
      1, on argument error.
      2, when no file is found. Most likely caused by a poor EXP and/or a
         shallow search depth.
      7, on dependency error.
    130, on keyboard interrupt.

DEPENDENCIES
    Coreutils:
    wc                (any)

    Other:
    fd                (v8.3.2+)
    fzf | fzy | zf    (v0.30.0+ | v1.0+ | v0.5+)
    vi  | vim | nvim  (any, optional with -E)

VERSION
    $VERSION

AUTHOR(S)
    $AUTHOR\n"
}

unset verWarn fnfWarn argErr dirErr depthErr ignoreErr noArgErr noFileErr depErr sigInt
sighandler() {
  [ "$verWarn"   = 1 ] && err 0 "using outdated $1 version ($2), requires at least $3"
  [ "$fnfWarn"   = 1 ] && err 0 "'$1' not found - skipping"
  [ "$argErr"    = 1 ] && err 1 "illegal argument - '$1'"
  [ "$dirErr"    = 1 ] && err 1 "directory '$1' does not exist"
  [ "$depthErr"  = 1 ] && err 1 'depth must be a positive, non-zero integer'
  [ "$ignoreErr" = 1 ] && err 1 "'$1' doesn't exist or doesn't have read permissions"
  [ "$noArgErr"  = 1 ] && err 1 "missing argument for '$1'"
  [ "$noFileErr" = 1 ] && err 2 'nothing to edit'
  [ "$depErr"    = 1 ] && err 7 "dependency not met - $1"
  [ "$sigInt"    = 1 ] && err 130 'interrupt'
}

err() {
  printf '%s: %s\n' "$PROGRAM" "$2" 1>&2
  [ $1 -gt 0 ] && exit $1
}

verifyArg() {
  [ -z "$2" -o "$2" = -- ] && noArgErr=1 sighandler $1
}

depAll() { # all of $@ are present
  for dep in "$@"; do
    if ! command -v $dep 1>/dev/null; then
      missingCount=$((missingCount+1))
      missingDeps="$missingDeps, $dep"
    fi
  done
}

depAny() { # any of $@ is present
  for dep in "$@"; do
    if command -v $dep 1>/dev/null; then
      value=$dep
      return 0
    fi
  done
  missingCount=$((missingCount+1))
}

getEditor() {
  depAny nvim vim vi
  [ -z $value ] && missingDeps="$missingDeps, vi | (n)vim" || editor=$value
  unset value
}

getFuzzy() {
  depAny fzf fzy zf
  [ -z $value ] && missingDeps="$missingDeps, fzf | fzy | zf" || fuzzy=$value
  unset value
}

checkSemver() {
  local dep curVer minVer major minor patch
  dep=$1; curVer=$2; minVer=$3
  major=${curVer%%.*}
  minor=${curVer#*.}; minor=${minor%.*}
  patch=${curVer##*.}
  [ $major$minor$patch -lt $minVer ] && verWarn=1 sighandler $dep $curVer $minVer
}

checkMajMinVer() {
  local dep curVer minVer
  dep=$1; curVer=$2; minVer=$3
  maj=${curVer%.*}
  min=${curVer#*.}
  [ $maj$min -lt $minVer ] && verWarn=1 sighandler $dep $curVer $minVer
}

fdVer() {
  local ver=`fd --version`
  checkSemver 'fd' ${ver#fd } 832
}

fzfVer() {
  local ver=`fzf --version`
  checkSemver 'fzf' ${ver% *} 0300
}

fzyVer() {
  local ver=`fzy --version`; ver=${ver#fzy }
  checkMajMinVer 'fzy' ${ver% Â©*} 10
}

zfVer() {
  local ver compat
  ver=`zf --version`; ver=${ver#zf }; ver=${ver%% *}

  # compatibility with `zf --version` output between 0.1.0 and 0.6.0
  compat=${ver#*.}; compat=${compat%.*}
  [ $compat -gt 0 -a $compat -le 5 ]\
    && checkMajMinVer 'zf' $ver 05 || checkSemver 'zf' $ver 060
}


# argument parsing ---------------------
depth=10
dir="$PWD"
exclPattern=''
exp='. / '
expList=''
gitignore='**/.git*,'
ignorefile="${0%/*}/exclude.nff"
ignore=''
symlinks=''

editor=''
fuzzy=''
fuzzyOpts=''
fzfOpts='-i -e --tiebreak=begin --reverse --prompt= --height=10 --no-color --no-info'
fzyOpts='--lines=10 --prompt='
zfOpts='--lines 10'

while [ -n "$1" ]; do
  case "$1" in
    --)
      shift
      for exp in "$@"; do
        [ "$expList" = "${expList%"$exp"*}" ] && expList="$expList$exp / "
      done
      break;;

    -h|--help)
      usage; exit 0;;

    -d|--depth)
      verifyArg $1 $2
      if [ $2 -eq $2 ] 2>/dev/null && [ $2 -gt 0 ]; then
        depth=$2
      else
        depthErr=1 sighandler
      fi
      shift 2;;

    -E|--editor)
      editor="$EDITOR"
      shift;;

    -i|--ignore)
      verifyArg $1 $2
      if [ "$2" = - ]; then
        unset ignorefile
        ignore='--no-ignore'
      else
        [ ! -f "$2" -o ! -r "$2" ] && ignoreErr=1 sighandler "$2"
        ignorefile="$2"
      fi
      shift 2;;

    -f|--zf)
      fuzzy=zf
      shift;;

    -g|--no-git-ignore)
      unset gitignore
      shift;;

    -l)
      symlinks=L
      shift;;

    -o|--fuzzy-opts)
      verifyArg $1 $2
      fuzzyOpts="$2"
      shift 2;;

    -p|--pattern)
      verifyArg $1 $2
      pattern=${2%/}
      exclPattern="$exclPattern**/${pattern#*/},"
      unset pattern
      shift 2;;

    -v|--version)
      printf "$PROGRAM $VERSION $AUTHOR\n";
      exit 0;;

    -y|--fzy)
      fuzzy=fzy
      shift;;

    -z|--fzf)
      fuzzy=fzf
      shift;;

    -*)
      err 1 "invalid argument - '$1'.";;

    *)
      for exp in "$@"; do
        # explicit split, argument invalid
        [ $exp = '--' ] && argErr=1 sighandler "$1"
      done

      [ "$1" != "${1%/}" -a ! -d "$1" ] && dirErr=1 sighandler "$1"
      if [ -d "$1" ]; then
        dir="$1"
        shift
      fi

      for exp in "$@"; do
        [ "$expList" = "${expList%"$exp"*}" ] && expList="$expList$exp / "
      done
      break;;
  esac
done


### dependency checks ------------------
missingCount=0; missingDeps='';
depAll wc fd

[ -z $editor ] && getEditor
[ -z $fuzzy ] && getFuzzy

[ $missingCount -gt 0 ] && depErr=1 sighandler "${missingDeps#, }"
unset dep missingDeps missingCount


### verion checks ----------------------
fdVer

if [ $fuzzy = fzf ]; then
  fzfVer
  fuzzyOpts="${fuzzyOpts:-$fzfOpts}"
elif [ $fuzzy = fzy ]; then
  fzyVer
  fuzzyOpts="${fuzzyOpts:-$fzyOpts}"
else [ $fuzzy = zf ]
  zfVer
  fuzzyOpts="${fuzzyOpts:-$zfOpts}"
fi


### execution --------------------------
# build exclude list
if [ -n "$gitignore" -o -n "$exclPattern" -o -n "$ignorefile" ]; then
  exclList='-E {'

  [ -n "$gitignore" ] && exclList="$exclList$gitignore"
  [ -n "$exclPattern" ] && exclList="$exclList$exclPattern"

  if [ -n "$ignorefile" ]; then
    while IFS='' read -r file; do
      file=${file%/}
      exclList="$exclList**/${file#*/},"
    done < "$ignorefile"
  fi

  exclList="$exclList}"
  unset exclPattern ignorefile
fi

# build file-string
files=''
fdCmd="fd $exclList -tf -H$symlinks $ignore -d$depth -p"

[ -z "$expList" ] && expList="$exp"
while [ -n "$expList" ]; do
  unset match
  count=`$fdCmd --max-results 2 -- "${expList%% / *}" "$dir" | wc -l`

  # emulate fzf's '-1' behaviour for all finders
  if [ $count -eq 1 ]; then
    match=`$fdCmd -- "${expList%% / *}" "$dir"`
  elif [ $count -gt 1 ]; then
    match=`$fdCmd -- "${expList%% / *}" "$dir" | $fuzzy $fuzzyOpts`
    code=$?
    if [ $code -ne 0 ]; then
      [ $fuzzy = fzf -a $code -eq 130 ] && sigInt=1 sighandler
      [ $code -eq 1 ] && sigInt=1 sighandler
      err 130 'uncaught fuzzy finder error.'
    fi
    unset code
  fi

  [ -n "$match" ]\
    && files="$files$match "\
    || fnfWarn=1 sighandler ${expList%% / *}

  [ "$expList" = "$exp" ] && break

  expList="${expList#* / }"
done

files="${files% }"

# open
[ -n "$files" ] && $editor $files || noFileErr=1 sighandler
