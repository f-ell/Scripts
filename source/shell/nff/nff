#!/bin/sh

# * move (fzy) '-1' implementation into isolated function
# * add -E option to use $EDITOR instead of the natively supported editors

Authors='Nico Pareigis'
Program=${0##*/}
Version=0.3.0

Usage() {
printf "NAME
    $Program - (Neo)Vim-Fuzzy-Finder - find file in filesystem and open it with
    Vi, Vim, or NeoVim

SYNOPSIS
    $Program [OPTS] [DIR] [-- EXP]

DESCRIPTION
    Recursively search through directories and select one or more files. The sel-
    ected file(s) will be opened in either Vi, Vim, or NeoVim. Should more than
    one of the aforementioned programs be installed, $Program will prioritize
    them in reverse order. Optionally, specify a search directory and / or ex-
    pression to be matched.

    DIR specifies the directory to run $Program in; the default is \$HOME.

    '-- EXP' allows the user to specify multiple search expressions / filenames
    as a space-separated list. If $Program finds a file matching the expression
    that file is added to a list; each file in the list will later be opened in
    its own buffer. If a match only has a single candidate, this is done auto-
    matically. Otherwise, fzf or fzy is used to interactively select a candidate.

    When using fzf as the fuzzy finder, part of the user's \$FZF_DEFAULT_OPTS may
    temporarily be overwritten.

    NOTE:
    Due to shell limitations, expressions / filenames containing spaces are
    currently unsupported and should not be used!

OPTIONS
    -d, --depth INT
      Takes a positive, non-zero Integer and uses it as the search depth. Using
      a high search depth has the advantage of showing better search results in
      deeply nested directory structures, but comes at the cost of a greater de-
      lay between issuing the command and opening the desired file(s).
      Default search depth is 10.

    -g, --no-git-ignore
      $Program excludes any file / directory matching '.git*' that it encounters
      during the search. Using this option prevents those matches from being re-
      moved from search results.
      Can be used in combination with patterns, specified either in a separate
      file, or on the command line (see -e and -p respectively), to only show
      specific git-related results.

    -i, --ignore FILE
      Use FILE containing patterns to ignore files and directories in search
      results. Patterns support globbing characters and should be separated by
      newlines. Avoid prefixing patterns with '**/', as that's how they are
      being matched internally and prefixing them as such would prevent exclu-
      sion of all files / directories that are first-hand children of DIR.
      Furthermore, patterns should consist of the shortest, unambiguous part of
      the filenames / directories one wishes to exclude.

      By default $Program tries to source a file called 'exclude.nff', located
      in the script's directory, to filter unwanted search results. If one wants
      to not exclude any results, ensure a file with aforementioned name does
      not exist in the script's directory, or pass '-' as FILE to this option.

      EXAMPLE:
      Assume the contents of '/path/to/first/directory/' are to be discarded but
      contents of '/path/to/second/directory/' are to be kept as search results.
      To achieve this, put 'first/directory' in the pattern file. Alternatively,
      if anything matching 'directory' is to be discarded just put 'directory'
      in the pattern file.

      The default 'exclude.nff' in this repository should give a good idea of
      how the file is structured, as well as provide a sane default setup that
      can easily be expanded upon.

    -l
      Include symlinked files in search results (traverses symlinks).

    -p, --pattern PATTERN
      Use PATTERN to exclude files / directories from being matched. Can be used
      more than once.
      See -e for an example on proper PATTERN formatting.

    -y, --fzy
      Force fzy as the fuzzy finder. Without this, $Program will default to
      using fzf, if both fzf and fzy are installed. No dependency or version
      checks are performed for fzy when using this option.

EXIT STATUS
      0, on success.
      1, on option error.
      2, when no file is found. Most likely caused by a poor EXP, accompanied by
         a shallow search depth.
      3, on dependency error.
    130, on keyboard interrupt.

DEPENDENCIES
    Coreutils:
    wc                (any)

    Other:
    fd                (tested with v8.3.2)
    fzf | fzy         (tested with v0.30.0 | v1.0)
    vi  | vim | nvim  (any)

VERSION
    $Version

AUTHOR(S)
    $Authors
"
}


unset SigInt DepErr VerWar DetErr DirErr IgnErr FnfWar
SigHandler() {
  [ "$VerWar" = True ] && Err   0 "'$1' version ($2) is outdated and may not work."
  [ "$FnfWar" = True ] && Err   0 "'$1' not found - skipping."
  [ "$DetErr" = True ] && Err   1 "depth has to be a positive, non-zero integer."
  [ "$DirErr" = True ] && Err   1 "directory '$1' does not exist."
  [ "$IgnErr" = True ] && Err   1 "file '$1' doesn't exist, isn't a valid file, or doesn't have read permissions."
  [ "$FilErr" = True ] && Err   2 'no valid file provided.'
  [ "$DepErr" = True ] && Err   3 "dependency not met - $1."
  [ "$SigInt" = True ] && Err 130 "keyboard interrupt."
}


### Helper functions
Err() {
  printf '%s: %s\n' "$Program" "$2" 1>&2
  [ $1 -gt 0 ] && exit $1
}
DepAllOf() { # all of $@ are present
  for Dep in "$@"; do
    if ! command -v $Dep 1>/dev/null; then
      MissingDepCount=$((MissingDepCount+1))
      MissingDeps="$MissingDeps, $Dep"
    fi
  done
}
DepAnyOf() { # any of $@ is present
  for Dep in "$@"; do
    if command -v $Dep 1>/dev/null; then
      Use=$Dep
      return 0
    fi
  done
  MissingDepCount=$((MissingDepCount+1))
}


### Dependency checks
MissingDepCount=0; MissingDeps=''; Editor=''; Finder=''
DepAllOf wc fd
DepAnyOf nvim vim vi
[ -z "$Use" ] && MissingDeps="$MissingDeps, vi | (n)vim"  || Editor=$Use
DepAnyOf fzf fzy
[ -z "$Use" ] && MissingDeps="$MissingDeps, fzf | fzy"    || Finder=$Use

[ $MissingDepCount -gt 0 ] && DepErr=True SigHandler "${MissingDeps#, }"
unset Dep Use MissingDeps MissingDepCount


### Dependency version checks
# fd
  FdCleanV=`fd --version`; FdCleanV=${FdCleanV#fd }
  Sup=${FdCleanV#?.}; Sup=${Sup%.?}
  FdV=${FdCleanV%%.*}; FdV=$FdV$Sup; FdV=$FdV${FdCleanV##*.}
  [ $FdV -lt 832 ]   && VerWar=True SigHandler fd $FdCleanV

# fuzzy finder
  if [ "$Finder" = fzf ]; then
    FzfCleanV=`fzf --version`; FzfCleanV=${FzfCleanV% *}
    Sup=${FzfCleanV#?.}; Sup=${Sup%.?}
    FzfV=${FzfCleanV%%.*}; FzfV=$FzfV$Sup
      FzfV=$FzfV${FzfCleanV##*.}
    [ $FzfV -lt 0300 ] && VerWar=True SigHandler fzf $FzfCleanV
  else
    FzyCleanV=`fzy --version`; FzyCleanV=${FzyCleanV#fzy }
      FzyCleanV=${FzyCleanV% Â©*}
    Sup=${FzyCleanV#?.}
    FzyV=${FzyCleanV%.?}$Sup
    [ $FzyV -lt 10 ] && VerWar=True SigHandler fzy $FzyCleanV
  fi

unset FdCleanV FzfCleanV FzyCleanV FdV FzfV FzyV Sup


### Argument processing
FzfOpts='-i -e --tiebreak=begin --reverse --prompt= --height=10 --no-color
  --no-info'
FzyOpts='--lines=10 --prompt='
Depth=10
Dir="$HOME"
IgnoreFile="${0%/*}/exclude.nff"
ExcludePattern=''
Exp='. / '
ExpList=''
GitIgnore='**/.git*,'
Link=''

while [ -n "$1" ]; do
  case "$1" in
    --)
      shift
      for Exp in "$@"; do
        [ "$ExpList" = "${ExpList%"$Exp"*}" ] && ExpList="$ExpList$Exp / "
      done
      break;;

    -h|--help)
      Usage; exit 0;;

    -d|--depth)
      if [ $2 -eq $2 ] 2>/dev/null && [ $2 -gt 0 ]; then
        Depth=$2
      else
        DetErr=True SigHandler
      fi
      shift 2;;

    -i|--ignore)
      if [ "$2" = - ]; then
        unset IgnoreFile
      else
        if [ ! -f "$2" ] || [ ! -r "$2" ]; then
          IgnErr=True SigHandler "$2"
        fi
        IgnoreFile="$2"
      fi
      shift 2;;

    -g|--no-git-ignore)
      unset GitIgnore
      shift;;

    -l)
      Link=L
      shift;;

    -p|--pattern)
      Pattern=${2%/}
      ExcludePattern="$ExcludePattern**/${Pattern#*/},"
      unset Pattern
      shift 2;;

    -y|--fzy)
      Finder=fzy
      shift;;

    -*)
      Err 1 "invalid option '$1'";;

    *)
      [ ! -d "$1" ] && DirErr=True SigHandler "$1"
      Dir="$1"
      shift;;
  esac
done


# Construct $ExcludeList
if [ -n "$GitIgnore" ] || [ -n "$ExcludePattern" ] || [ -n "$IgnoreFile" ]; then
  ExcludeList='-E {'

  [ -n "$GitIgnore" ]       && ExcludeList="$ExcludeList$GitIgnore"
  [ -n "$ExcludePattern" ]  && ExcludeList="$ExcludeList$ExcludePattern"

  if [ -n "$IgnoreFile" ]; then
    while IFS='' read -r File; do
      File=${File%/}
      ExcludeList="$ExcludeList**/${File#*/},"
    done < "$IgnoreFile"
  fi

  ExcludeList="$ExcludeList}"
  unset ExcludePattern IgnoreFile
fi


[ "$Finder" = fzf ] && FinderOpts="$FzfOpts" || FinderOpts="$FzyOpts"
unset FzfOpts FzyOpts


# Construct $Files string
OneFile=True
Files=''
FdCmd="fd $ExcludeList -tf -H$Link -d$Depth"

[ -z "$ExpList" ] && ExpList="$Exp"
while [ -n "$ExpList" ]; do
  # Emulate fzf's '-1' behaviour for fzy
  [ `$FdCmd --max-results 2 -- "${ExpList%% / *}" "$Dir" | wc -l` -ne 0 ] \
    && OneFile=False || OneFile=True

  if [ "$OneFile" = False ]; then
    Match=`$FdCmd -- "${ExpList%% / *}" "$Dir" | $Finder $FinderOpts`
  else
    Match=`$FdCmd -- "${ExpList%% / *}" "$Dir"`
  fi

  Exit=$?
  if [ "$Finder" = fzf ]; then
    [ $Exit -eq 130 ] && SigInt=True SigHandler
  else
    [ $Exit -eq 1 ]   && SigInt=True SigHandler
  fi
  unset Exit

  [ -n "$Match" ] && Files="$Files$Match " \
    || FnfWar=True SigHandler ${ExpList%% / *}

  [ "$ExpList" = "$Exp" ] && break

  ExpList="${ExpList#* / }"
done; Files="${Files% }"


# Open files
[ -n "$Files" ] && $Editor $Files || FilErr=True SigHandler
