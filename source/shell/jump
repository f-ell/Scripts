#!/usr/bin/bash

# TODO:
# * doc
#   * fd uses smartcase
#   * pattern -> anything understood by fd
#
# * exclude patterns in J_EXCLUDE

program='j'
author='Nico Pareigis'
version='0.0.3'

TMPDIR="/tmp/$USER"
TMPSRC="$TMPDIR/j_src"

function err {
  printf '%s: %s\n' "$program" "$2" 1>&2
  (( $1 > 0 )) && exit $1
}

function sighandler {
  (( ${int-0} == 1 )) && err 130 'interrupt'
  (( ${dep-0} == 1 )) && err 3 "dependency not met - $1"
  (( ${dir-0} == 1 )) && err 2 "could not create directory '$1'"
  (( ${tmp_store-0} == 1 )) && err 0 "warning - failed writing jump information to '$1'"
  (( ${tmp_read-0} == 1 )) && err 2 'could not read jump information'
  (( ${tmp_exist-0} == 1 )) && err 2 'no jump information available'

  (( ${arg-0} == 1 )) && err 1 "unrecognized option - $1"
  (( ${optarg-0} == 1 )) && err 1 "invalid argument for option '$1' - $2"
  (( ${optmis-0} == 1 )) && err 1 "missing argument for option '$1'"
  (( ${result-0} == 1 )) && err 1 'no matches found'
}

function arginvalid {
  # FIX: ensure $1 isn't a valid option
  [[ -z $1 || $1 == -- ]]
}

function dep {
  declare -a missing

  for dep in "$@"; do
    if ! command -v $dep 1>/dev/null; then
      missing+=($dep)
    fi
  done

  declare deps="${missing[@]}"
  ((${#missing[@]} > 0)) && dep=1 sighandler "${deps// /, }"
}

function proc {
  while [[ -n $@ ]]; do
    case "$1" in
      -a|--all)
        opts[hidden]='-H'
        shift;;
      -b|--back)
        jump_back
        shift;;
      -d|--depth)
        declare arg=$1
        shift
        arginvalid "$1" && optmis=1 sighandler $arg
        [[ $1 =~ ^[[:digit:]]+$ ]] && (( $1 > 0 )) || optarg=1 sighandler $arg $1
        opts[depth]=$1
        shift;;
      -f|--zf)
        opts[fuzzy]='zf'
        shift;;
      -h|--help)
        err 5 'not implemented yet';;
      -l|--follow-links)
        opts[links]='-L'
        shift;;
      -v|--version)
        err 5 'not implemented yet';;
      -y|--fzy)
        opts[fuzzy]='fzy'
        shift;;
      -z|--fzf)
        opts[fuzzy]='fzf'
        shift;;
      -*)
        [[ $1 != -- ]] && arg=1 sighandler $1;&
      --|*)
        [[ $1 == -- ]] && shift
        patterns+=($@)
        break;;
    esac
  done
}

# ----------------------------------------------------------

function jump {
  store_jump_info "$1"
  printf "cd \"$1\"\n"
}

function jump_back {
  [[ ! -f $TMPSRC ]] && tmp_exist=1 sighandler $TMPSRC
  [[ ! -r $TMPSRC ]] && tmp_read=1 sighandler $TMPSRC

  read < $TMPSRC
  printf "cd \"$REPLY\"\n"

  exit 0
}

function jump_or_query {
  (( ${#@} == 1 )) && jump "$1" || query $@
}

function query {
  declare dir=`printf "%s\n" $@ | ${opts[fuzzy]}`
  [[ -z $dir ]] && int=1 sighandler

  store_jump_info "$dir"
  printf "cd \"$dir\"\n"
}

function store_jump_info {
  [[ ! -d "$TMPDIR" ]] && { mkdir "$TMPDIR" || dir=1 sighandler "$TMPDIR"; }
  printf "$PWD\n" 1> "$TMPSRC" || tmp_store=1 sighandler "$TMPSRC"
}

# execution
declare -A opts=(
  [depth]=8
  [fuzzy]='fzf'
  [hidden]=
  [links]=
)
declare -a patterns

proc $@
dep realpath fd rg ${opts[fuzzy]}

IFS='|'
declare fd=`fd -d${opts[depth]} -td ${opts[hidden]} ${opts[links]} -- "${patterns[*]}"`
unset IFS
declare -a matches=(${fd//$'\n'/ })

(( ${#matches[@]} == 0 )) && result=1 sighandler

jump_or_query ${matches[@]}

exit 0
